/**

\page StylesAndNotesPage The MITK Style Guide and Technical Notes
 
The style guide for MITK is almost identical to that of ITK, see the 
ITK Style Guide document. The only difference is that
MITK has its own namespace (@a mitk ).

Some technical notes:
\li The names of the files containing a class @a ExampleClass should be @a mitkExampleClass.h/.cpp.
\li Use forward declarations in header files wherever possible. Only include those header files in a header file 
that are really necessary. Include the rest in the implementation file.
\li For classes inheriting directly or indirectly from @a itk::LightObject (most of the MITK-classes do so), the
class definition should include the mitkClassMacro. Additionally, if the class can be instantiated (normally the case, 
if the class is not abstract) and has @em only a constructor without parameters, the constructor should be declared 
protected and the @a itkNewMacro should be used to create a @a New() method for instantiation. Here is an example:
@code
class ExampleClass : public SuperClassOfTheExampleClass
{
public:
    mitkClassMacro(ExampleClass, SuperClassOfTheExampleClass);
    itkNewMacro(Self); // Self is a typedef to the class name generated by the mitkClassMacro
    [...]
protected:
    ExampleClass();
    virtual ~ExampleClass();
}    
@endcode
\li The standard indention is two spaces (see ITK Style Guide). Configure your
editor accordingly. Do not use tabs!
\li @a SmartPointers must be used for classes that have @a itk::Object as a base class. 
Assignment of a just created instance to a normal pointer, e.g., 
@code itk::Object* crash = itk::Object::New()@endcode results in a crash, since the reference count 
is decreased immediately to zero and the object is destroyed. Use: @code itk::Object::Pointer nocrash = itk::Object::New()@endcode 
Static declarations are also forbidden and result into an exception when the scope of the variable is left, because the destructor is called 
while the reference count is still greater than zero. 
\li Note that using smart pointers requires using real (normal) pointers when setting input. If you want to return a newly created
smart pointer that is not also kept within the class (e.g., if you write a \a Clone method), you have to return a  
smart pointer on output (compare <a href="http://www.itk.org/Doxygen12/html/itkMacro_8h.html">itkMacro.h</a>). If the 
smart pointer is kept within the class, returning a real (normal) pointer is sufficient.
\li Testing a SmartPointer against NULL is done with the IsNull() and IsNotNull() methods. A simple ==NULL issues a warning.
\li Set- and Get-methods can be created with the macros @a itkSetObjectMacro(name,type) and 
@a itkGetObjectMacro(name,type), respectively, if the @a type is derived from @a itk::LightObject or
@a itk::Object. There are also macros for other types, e.g., strings, see 
<a href="http://www.itk.org/Doxygen12/html/itkMacro_8h.html">itkMacro.h</a>.
\li When using inner classes of a parent class which is templated, you have
to use the keyword @a typename for gcc 3.x and standard compliance. For example, 
@a TreeChangeListener is an inner class of @a Tree, therefore use:
@code
class LinkedTree : public Tree<T>
{

public:
    typedef typename LinkedTree<T>::TreeChangeListener TreeChangeListener;
    [...]
}    
@endcode
Another example:
@code
typename std::vector<TreeChangeListener*>::iterator pos = treeChangeListenerList.begin();
@endcode
@a iterator is an inner class of @a vector.
\li Constants in MITK for Operations and SideEffects are set in namespace, so don't forget to add prefix @a mitk:: 
@code
switch (sideEffectId)
  {
  case mitk::SeMOVESELECTED:
@endcode
Prefixes for the constants are to be used like corresponding others. See file @a Interactions\\mitkBaseInteraction\\mitkInteractionConst.h for further details.
\li Often QmitkFunctionality::activated() and QmitkFunctionality::deactivated() is the right place to connect and disconnnect event-handlers 
(e.g., mitk::GlobalStateMachine::AddStateMachine() in activated() and mitk::GlobalStateMachine::RemoveStateMachine()
 in deactivated()).
\li The four widgets of the QmitkStdMultiWidget should be initialized in QmitkFunctionality::activated(),
 but does @em not need to be restored in QmitkFunctionality::deactivated(): It is the responsiblity of the 
 subsequently activated functionality to initialize them according to its needs.
*/
