/**

\page QtWidgetPage Preparing Qt widgets for the Designer

\b Important: This page refers to Qt 3.3 (and some earlier versions probably). In Qt 4 the 
plugin interface has changed, so the information given here does not apply.

This page describes the packaging of newly created Qt widgets into widget plugins suitable for the
Qt Designer. Your widgets will displayed correctly inside the designer, just like a QLabel or
QTextEdit. Major parts of this page were taken from the <a href="http://doc.trolltech.com/3.3/designer-manual-7.html">
Qt Designer Manual - Creating Custom Widgets</a>. This page just summarizes and links to useful pages.

Creating a new widget plugin requries several steps:
\li \ref widget - How you create a new widget, unrelated to the Designer
\li \ref plugin - What makes up a widget plugin for the Designer 
\li \ref designer - Where to put your plugin

\section widget Creating a new widget

A new widget means a subclass of <a href="http://doc.trolltech.com/3.3/qwidget.html">QWidget</a>.
When you consider plugins for the Designer, you probably know how to subclass QWidget and make a
widget do useful things - then move on to \ref plugin.

The following demonstrates what is important about a widget class: the Q_OBJECT macro should be the
first thing to add - it enables the <a href="http://doc.trolltech.com/3.3/metaobjects.html">meta
object compiler</a> to create meta object code, implementing the signal and slot mechanism and some
more features of Qt.

The usage of Q_ENUMS() and Q_PROPERTY() demontrates how to create "real" Qt properties. In the
example, both properties \a mode and \a pixmap will be available in the Designer. Making properties
designable means less initialisation code for the users of your widget.

Not really visible here, but an important aspect of Qt, is the <a
href="http://doc.trolltech.com/3.3/signalsandslots.html">signal and slot mechanism</a>. Signals are
declared in the public: section of your class, while slots can be either public, protected or
private, whatever suits you needs.

\code
#include <qframe.h>

class QUndoRedoButton : public QFrame
{
  Q_OBJECT
  Q_ENUMS( Mode )
  Q_PROPERTY( Mode mode READ getMode WRITE setMode )
  Q_PROPERTY( QPixmap pixmap READ pixmap WRITE setPixmap )
  
  public:

    enum Mode { Undo, Redo };

    QUndoRedoButton( QWidget* parent = 0, const char* name = 0 );
    virtual ~QUndoRedoButton();
    const QPixmap *pixmap() const;
    void setPixmap( const QPixmap& pm );
    
    Mode getMode() const;

  signals:
    void undoRedoLast(int); // Emitted, when button is pressed or a number of
                            // actions is selected

  public slots:
    void clear();
    void setMode( Mode m );

  protected:
    Mode m_Mode;

  private:
};
\endcode

\section plugin Writing a plugin for a (set of) widget(s)

A widget plugin for the designer consists basically of a single class, which is derived from <a
href="http://doc.trolltech.com/3.3/qwidgetplugin.html">QWidgetPlugin</a>. 
This class implements some virtual functions, which are called by the Designer, when it needs to
know, what widgets are available, what their icons look like, where to place them in the toolbox,
etc. In C++ that looks like

\code
#include <qwidgetplugin.h>

class QUndoRedoButtonPlugin : public QWidgetPlugin
{
public:
    QUndoRedoButtonPlugin();

    QStringList keys() const;
    QWidget* create( const QString &classname, QWidget* parent = 0, const char* name = 0 );
    QString group( const QString& ) const;
    QIconSet iconSet( const QString& ) const;
    QString includeFile( const QString& ) const;
    QString toolTip( const QString& ) const;
    QString whatsThis( const QString& ) const;
    bool isContainer( const QString& ) const;
};
\endcode

Now to the methods and what they need to do. Constructor and destructor can be empty, unless you
want to put functionality there. The first thing in your implementation will probably be one or
several icons, which you want to appear in the toolbox. I found it easiest to directly put the
contents of XPM images here, or just #include it.

\code
#include "plugin_QmitkUndoRedoButton.h"

#include "QUndoRedoButton.h"  // the button from the previous section
#include "QRedoButton.h"      // some other widget

static const char *undoredobutton_xpm[] = {
"18 11 5 1",
" 	c None",
".	c #00008B",
"+	c #000083",
"@	c #8B858B",
"#	c #838183",
"         .+.+.+@  ",
".      +.+.+.+.+. ",
"+.   .+.+      .+@",
".+. .+.         .+",
"+.+.+.          +.",
".+.+.           .+",
"+.+.+.          +.",
".+.+.+.         .+",
"+.+.+.+.       .+@",
"             #.+. ",
"             .+.  "
};
\endcode

The <i>keys()</i> method tells the Designer a number of widgets your plugin can construct. You simply
return a <a href="http://doc.trolltech.com/3.3/qstringlist.html">QStringList</a>. 
The most important rule (the Qt Designer documentation stresses this not enough): 
The strings you return here, <i>must be identical</i> to your widget classes' names! 

It may seem
unnatural to put something other here, but the Designer will strip the leading "Q" and all following
lowercase characters (until the next uppercase character) from these strings, when displaying them
in the toolbox. You if you happen to name your class QmitkRenderManagerEdit it will appear as
"RenderManagerEdit". A widget named QvtkRenderManagerEdit will appear under exactly the same name
"RenderManagerEdit". But still, <b>always use your real C++ class names here</b>.
Otherwise some part of the Designer or the widget factory or whatever will get confused and you'll
experience strange side effects, like your widget appears on the form but not in the preview, or
header files required by your widget won't appear in the .ui file. 

\code
QStringList QUndoRedoButtonPlugin::keys() const
{
    QStringList list;
    list << "QUndoRedoButton" << "QRedoButton";
    return list;
}
\endcode

The <i>create()</i> method of the widget plugin is called by the Designer, when it needs to add your
widget to a form. \a key is one of the strings you returned in <i>keys()</i>. All you have to do in this
method, is check, which widget is asked for and then return an instance of that widget.

\code
QWidget* QUndoRedoButtonPlugin::create( const QString &key, QWidget* parent, const char* name )
{
    if ( key == "QUndoRedoButton" )
        return new QUndoRedoButton( parent, name );
    if ( key == "QRedoButton" )
        return new QRedoButton( parent, name );
    return NULL;
}
\endcode

The methods <i>group(), iconSet()</i> and <i>includeFile(), toolTip()</i>, and <i>whatsThis()</i> are
pretty self-explanatory, so here are examples of their implementation.

\code
QString QUndoRedoButtonPlugin::group( const QString& feature) const 
{
    if ( feature == "QUndoRedoButton" ) return "MITK";
    if ( feature == "QRedoButton" ) return "Input";
    return QString::null;
}

QIconSet QUndoRedoButtonPlugin::iconSet( const QString& feature) const
{
    
  if ( feature == "QUndoRedoButton" ) return QIconSet( QPixmap( undoredobutton_xpm ) );
  if ( feature == "QRedoButton" )     return QIconSet( QPixmap( undoredobutton_xpm ) );
  return QIconSet();
}

QString QUndoRedoButtonPlugin::includeFile( const QString& feature ) const
{
  if ( feature == "QUndoRedoButton" ) return QString("QUndoRedoButton.h");
  if ( feature == "QRedoButton" )     return QString("qredobutton.h");
  return QString::null;
}

QString QUndoRedoButtonPlugin::toolTip( const QString& feature ) const
{
    if ( feature == "QUndoRedoButton" ) return "A Undo/Redo Button like in Word";
    if ( feature == "QRedoButton" )     return "A Redo Button like in Word";
    return QString::null;
}

QString QUndoRedoButtonPlugin::whatsThis( const QString& feature ) const
{
    if ( feature == "QUndoRedoButton" ) return "A Undo/Redo Button like in Word";
    if ( feature == "QRedoButton" )     return "A Redo Button like in Word";
    return QString::null;
}
\endcode

<i>isContainter</i> tells the Designer, wheter a widget may be parent of other widgets (like QFrame).
Default to false, so you don't have to implement it.

\code
bool QUndoRedoButtonPlugin::isContainer( const QString& ) const
{
    return FALSE;
}
\endcode

Then, there is a macro you have to add once to your implementation. It makes your plugin class
available through a fixed function call (needed since the Designer cannot know you classes name).
\code
  Q_EXPORT_PLUGIN( QUndoRedoButtonPlugin )
\endcode

\section compile Building the plugin

While implementing the plugin, you probably want to test the plugin before adding it to any build
process (the Qmitk build in our case). The easiest way to do so, is to use Qmake.

\subsection compile_qmake Using Qmake

Write a \c plugin.pro file like this
\code
TEMPLATE = lib
LANGUAGE = C++
TARGET   = my_plugin

SOURCES  += plugin_QmitkUndoRedoButton.cpp ../widget/QmitkUndoRedoButton.cpp ../widget/QRedoButton.cpp
HEADERS  += plugin_QmitkUndoRedoButton.h ../widget/QmitkUndoRedoButton.h ../widget/QRedoButton.h
DESTDIR   = /home/user/.kde/lib/kde3/plugins/designer

target.path=$$plugins.path   # no idea what this line does

INSTALLS    += target
CONFIG      += qt warn_on release plugin
INCLUDEPATH += $$QT_SOURCE_TREE/tools/designer/interfaces
DBFILE       = plugin.db
\endcode

Then you type \c qmake; \c make and you find a newly created shared library in \c
/home/user/.kde/lib/kde3/plugins/designer. With Linux this will be \c libmy_plugin.so, with Windows
\c my_plugin.dll.

\subsection windll And now for the Windows related problems

When building a shared library for windows, you have to tell the compiler and linker, which symbols
from the library should be exported (or imported, when using the DLL). This can be done either by
creating \c .def files, containing all the symbol names you want to export (keywords: DLL export
symbols dumpbin), or by using a Microsoft extension of C++. On this page, only the use of the
Microsoft extension is described.

The name of the extension is \c dllexport. You have to change you header files, so that they read
\code
class __declspec(dllexport) QUndoRedoButtonPlugin : public QWidgetPlugin { ... };
class __declspec(dllexport) QUndoRedoButton: public QFrame { ... };
class __declspec(dllexport) QRedoButton: public QWidget { ... };
\endcode

Doing this and starting a new build with \c qmake; \c make should build a DLL, which can be properly
used by the Designer.

If you want to use your widgets directly from this DLL, you have to define a dependency between your
program and this DLL. You have to find out how this works, I never used this.
Then, you have to include the headers of your widgets somewhere in your code. And where you include
them, they should read
\code
class __declspec(dllimport) QUndoRedoButtonPlugin : public QWidgetPlugin { ... };
class __declspec(dllimport) QUndoRedoButton: public QFrame { ... };
class __declspec(dllimport) QRedoButton: public QWidget { ... };
\endcode

This is usually done by defining a macro like
\code
#if defined(WIN32)
  #if defined(BUILDING_DLL)
    #define DLL_EXPORT __declspec(dllexport)
  #else
    #define DLL_EXPORT __declspec(dllimport)
  #endif
#else
  #define DLL_EXPORT
#endif
\endcode

Then you change your headers to
\code
class DLL_EXPORT QUndoRedoButtonPlugin : public QWidgetPlugin { ... };
class DLL_EXPORT QUndoRedoButton: public QFrame { ... };
class DLL_EXPORT QRedoButton: public QWidget { ... };
\endcode

When building your DLL, you will define \c BUILDING_DLL (with a compiler switch -D BUILDING_DLL or
something similar). Then the macro expands to __delspec(dllexport). When you use your headers in you
main program's code, you don't define \c BUILDING_DLL, and the macro correctly expands to
__declspec(dllimport). 

When you use Linux, the macro always expands to nothing. 

MacOS may require still other hints for the linker...

\subsection compile_cmake CMake and the MITK build 

When creating a widget for Qmitk, you can use the \c MITK_EXPORT macro, defined in
\c mitkCommon.h. Write something like 

\code
#include "mitkCommon.h"

class
MITK_EXPORT
QmitkNodeDisplayWidget : public QWidget { ... };
\endcode

Then you add a section to the CMake file for this widget, where you build a shared library. This
could look like the following (from \c ip++/AppModules/QmitkUndoRedoButton/QmitkUndoRedobutton.cmake)
\verbatim
# Second part:  build a separate .so/DLL for the Qt Designer
# Create moc files for the Qt files

SET ( PLUGIN_MOC_H    ../../AppModules/QmitkUndoRedoButton/QmitkUndoRedoButton.h
                      ../../AppModules/QmitkUndoRedoButton/qundoredobutton.h
                      ../../AppModules/QmitkUndoRedoButton/popupundoredo.h
                      ../../AppModules/QmitkUndoRedoButton/popupactionhistory.h )
SET ( PLUGIN_CPP  ../../AppModules/QmitkUndoRedoButton/QmitkUndoRedoButton.cpp
                  ../../AppModules/QmitkUndoRedoButton/qundoredobutton.cpp
                  ../../AppModules/QmitkUndoRedoButton/popupundoredo.cpp
                  ../../AppModules/QmitkUndoRedoButton/popupactionhistory.cpp )

# create moc files for all headers (all headers contain QObjects)
QT_WRAP_CPP( QmitkUndoRedoButton_plugin PLUGIN_CPP ${PLUGIN_MOC_H} )

# The widget plugin should be built as a shared library
ADD_LIBRARY( QmitkUndoRedoButton_plugin SHARED  ${PLUGIN_CPP} ../../AppModules/QmitkUndoRedoButton/plugin/plugin_QmitkUndoRedoButton.cpp )

# When building the DLL/.so, BUILDING_MITK_DLL should be defined (so __declspec(dllexport) can be used properly for Windows)
SET_TARGET_PROPERTIES( QmitkUndoRedoButton_plugin PROPERTIES
                         DEFINE_SYMBOL BUILDING_MITK_DLL)

# The ITKCommon library is needed by the plugin, so it should be linked 
TARGET_LINK_LIBRARIES( QmitkUndoRedoButton_plugin ITKCommon ${QT_LIBRARIES})
\endverbatim

Note, that currently the \c MITK_EXPORT macro is defined so that it expands to nothing, when no
special \c \#define is set. That is, the plugin is built as a shared library, which can be used with
the Designer. But the widget is compiled into the Qmitk library, too. Otherwise a new dependency
on a DLL for a single widget would be added.

If you want to add this dependency, you can define \c IMPORTING_MITK_DLL when compiling Qmitk. Is
that case, your program will not run without the widget DLL.

\section designer Making the Designer aware of the plugin

Finally to the easy part: you have to put the plugin in a place where the Designer looks for
plugins. In the Designer's menu \c Edit/Preferences the tab \c General contains an area "Plugin
Paths". You have to make sure, that your plugin is in one of those paths.

In the Designer's menu \c Edit/Preferences the tab \c General contains an area "Plugin Paths". You
have to make sure, that your plugin is in one of those paths.

**/
