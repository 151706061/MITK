/**

\page InteractionPage Interaction and Undo/Redo Concepts
 
\section InteractionIntroduction Interaction in MITK 

\b Interaction is one of the most important tasks in clinically useful image processing software. 
Due to that, MITK has a special interaction concept, with which the developer can map the desired interaction. 
For a simple change in interaction he doesn't have to change the code. All information about the sequence 
of the interaction is stored in an XML-file that is loaded by the application during startup procedure at runtime.
That even allows the storage of different interaction patterns, e.g. an interaction behaviour like in MS PowerPoint, 
in Adobe Photoshop or like the interaction behaviour on a medical image retrieval system.

\section Statemachines Statemachines to realize Interaction
The interaction in MITK is realized with the concept of statemachines (by Mealy).
This concept allows to build the steps of interaction with different states, which each have different conditions, very alike the different interactions that may have to be build to develop medical imaging applications.
Furthermore statemachines can be implemented using object oriented programming (OOP). Due to that we can abstract from the section of code, that implements the interaction and focus on the sequence of interaction. What steps must the user do frst before the program can compute a result? For example he has to declare three points in space first and these points are the input of a filter so only after the definition of the points, the filter can produce a result. The according interaction sequence will inform the filter after the third point is set and not before that. Now the filter after an adaption only needs two points as an input. The sequence of the interaction can be easily changed if it is build up as a sequence of objects and not hard implemented in a e.g. switch/case block. Or the user wants to add a point in the scene with the right mouse button instead of the left. Wouldn't it be nice to only change the definition of an interaction sequence rather than having to search through the code and changing every single if/else condition?

\subsection Statemachine Statemachine
So a separation of the definition of a sequence in interaction and its implementation is a usefull step in the development of an interactive application.
To be able to do that, we implemented the concept of statemachines with several classes: States, Transitions and Actions define the interaction pattern. The Statemachine itself adds the handling of events, that are send to it.

\image html statemachine.jpg

\subsubsection ExampleA Example A: 
A deterministic Mealy-statemachine has always one current state (here state 1). If an event 1 is sent to the statemachine, it searches in its current state for a transition that waits for event 1 (here transition 1). The statemachine finds transition 1, changes the current state to state2, cause the transition points to it and executes actions 1 and 2. Now state 2 is the current state. The statemachine recieves an event 2 and searches for an according transition. Transition 2 waits for event 2, and since the transition leads to state 2 the current state is not changed. Action 3 and 4 are executed. Now Event 3 gets send to the statemachine but the statemachine can't find an according transition in state 2. Only transition 2 , that waits for event 2 and transition 4, that waits for event 4 are defined in that state. So the statemachine ignores the event and doesn't change the state or execute an action. Now the statemachine recieves an event 4 and finds transition 3. So now the current state changes from state 2 to state 1 and actions 5 and 1 are executed.

Several actions can be defined in one transition. The execution of an action is the active part of the statemachine. Here is where the statemachine can make changes in data, e.g. add a Point into a list.


\subsection GuardState Guard States
Guard States are a special kind of states. The action, that is executed after the state is set as current state, sends a new event to the statemachine, which leads out of the guard state. So the statemachine will only stay in a guard state for a short time. This kind of state is used to check different conditions, e.g. is an Object is picked of a set of points will be full after the addition of one point.

\image html statemachine_guard.jpg

\subsubsection ExampleB Example B: 
Event 1 is send to the statemachine. This leads the current state from state 1 into state check. The action 1 is executed. This action checks a condition and puts the result into a new event, that is send an handled by the same (this) statemachine. E.g. is the the object, the statemachine handles the interaction, picked with the recieved mouse-koordinate? The event, that is generated, will be Yes or No. In case of event No, the statemachine sets the current state back to state 1 and executes action 2. In case of event Yes, the statemachine changes the state from state check into state 2 and executes action 3, which e.g. can select the object taken care of.

\subsection XMLDefinitionStatemachine Definition of a Statemachine
Due to the separation of the definition of an interaction sequence and its implementation, the definition has to be archived somewhere, where the application can reach it during startup and build up all the objects (states, transitions and actions) that represent the sequence of a special interaction. In MITK, these informations are defined in an XML-file (usually in Interaction/mitkBaseInteraction/StateMachine.xml).
The structure is the following (from \ref ExampleA) :

@code
  <stateMachine NAME="statemachine1">					<!-- defining a new statemachine with its name -->
    <state NAME="State1" ID="1" START_STATE="TRUE">			<!-- new state tag;this state is the startstate of the statemachine and has ID=1 -->
      <transition NAME="transition1" NEXT_STATE_ID="2" EVENT_ID="1">	<!-- transition, that waits for event with the ID=1 and leads to state 2 -->
        <action ID="1" />						<!-- action ID = 1 shall be executed --> 
        <action ID="2" />						<!-- action ID = 2 shall be executed --> 
      </transition>							<!-- end of transition -->
    </state>								<!-- end of state ID = 0 -->
    <state NAME="state2" ID="2">						
      <transition NAME="transition2" NEXT_STATE_ID="2" EVENT_ID="2">
        <action ID="3" />
        <action ID="4" />
      </transition>
      <transition NAME="transition3" NEXT_STATE_ID="1" EVENT_ID="4" >
        <action ID="5" />
        <action ID="1" />
      </transition>
    </state>
  </stateMachine>
@endcode

The identification numbers (ID) inside a statemachine has to be unique. Each statemachine has to have one state, that is defined as the start-state of that statemachine. This means, initialy, the current state of the statemachine is the start-state. 

During startup the structure of all statemachines are ckecked for not having states, that have no transitions leading out of it (dead states), or states, that have no transitions leading into it (magic states) [Bin99 p. 183]. If an error is found, an error-message will be displayed and the statemachine will be loaded.

\subsection references References
[Bin99] Robert V. Binder. Testing Object-Oriented Systems: Models, Patterns, and Tools. Addison-Wesley, 1999
 */
