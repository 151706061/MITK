
/**

\defgroup Mapper Mapper Classes
\ingroup Visualization

\brief In the MITK rendering concept, Mappers are responsible for actually rendering data onto the screen.


\section overviewVisualizationMapper Overview

Mappers differ in the type of data they are capable of rendering (e.g. volume data, polygonal data) and the mode of how data is rendered (e.g. 2D or 3D). For example, the ImageMapper2D renders volume data in a 2D view, i.e. it extracts a slice of the volume (as determined by the Geometry of the associated Renderer) and displays it as a 2D plane. All Mapper classes are arranged in a class hierarchy according to these criterions.


\section integrationVisualizationMapper Integration into the rendering process

Mapper objects are owned by the DataTreeNode which contains the data they have to render. An overview over this composition is given in the section \ref Renderer. Each DataTreeNode can have (and usually has) multiple Mappers attached, each responsible for different modes of rendering. In most cases this would be one 2D Mapper and one 3D Mapper, but other Mappers are possible, too.

The following sequence diagram outlines object interactions during rendering in a simplified way:

\image html RenderingSequence.png "Simplified rendering sequence"

The rendering of the scene in a particular window is invoked by a call to the Render() method of the associated Renderer object. The Renderer in turn iterates over all DataTreeNodes that are contained in the data tree (or sub-tree) it has been configured with. (The Renderer has to be initialized with the root node of the DataTree to be rendered.) During a first iteration pass, the Update() method of the Mappers attached to the DataTreeNodes is called. It prepares the Mapper to render the associated data (e.g. by initializing a required filter pipeline), but does not execute the actual rendering yet. Which Mapper of a DataTreeNode to use is determined by an ID; the Renderer of a 2D Window would for example ask the DataTreeNode to return an appropriate 2D Mapper. Afterwards, the rendering of the scene is executed. This is done in two steps: First, all VTK-based Mappers (VolumeMapper3D in the above example diagram) are rendered by simply calling Render() on the underlying vtkRenderWindow. VTK can take care of the whole rendering execution on its own, since the rendering pipelines have been set up before (usually by the Update() mentioned above). The stepwise execution of the VTK rendering pipeline is indicated by the message <em>Initiate Rendering</em> in the above diagram. Second, all non-VTK-based Mappers (ImageMapper2D above) are rendered. This has to be done explicitely by calling Paint() on every individual Mapper (again by iterating over the DataTree), since their rendering is not under VTK's direct control.


\section todoVisualizationMapper Future plans

At the moment, two kinds of mapping approaches exist, as described in the previous section: Mappers based on VTK and Mappers with VTK-independent rendering. In order to simplify the whole rendering process, a unification of Mappers is targeted; Mappers should unvariably adhere to the VTK-based approach. To achieve this, either all currently existing non-VTK-based Mappers could be reimplemented, or a wrapping mechanism allowing to retain existing rendering code could be deviced. Since a significant number of Mappers is non-VTK-based (notable 2D Mappers) and VTK currently only has limited support for certain features like layering of 2D images, the second approach seems to be the short-term solution of choice.

The need to Update() a Mapper (see above) can be justified by property changes in the associated data items. However, property changes are not uniformly taken into account when deciding on whether to execute Update() or not. The changes are data specific and difficult to generalize. As an effect, many Update() calls are not really necessary and might slow down the rendering process significantly. One solution to this problem might be a mechanism which allows Mappers to register themselves to relevant data properties, so as to be notified whenever a change occurs. If no modification did occur since the last Update(), and the data itself has remained unchanged, no re-initialization (of the rendering pipeline for example) needs to be performed.
*/
