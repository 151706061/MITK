
SET(ALL_FUNCTIONALITY_NAMES ${MITKFUNCTIONALITY_NAMES} ${MBIQMFUNCTIONALITY_NAMES} ${MBISBFUNCTIONALITY_NAMES})
SET(ALL_KNOWN_FUNCTIONALITY_NAMES ${MITKFUNCTIONALITY_NAMES_KNOWN} ${MBIQMFUNCTIONALITY_NAMES_KNOWN} ${MBISBFUNCTIONALITY_NAMES_KNOWN})
FOREACH(FUNC_NAME ${ALL_FUNCTIONALITY_NAMES})
# first check if name is known, otherwise the name is maybe left from before and
# the functionality doesn't exist anymore, e.g. because the build system was 
# modified.
IF(ALL_KNOWN_FUNCTIONALITY_NAMES MATCHES ${FUNC_NAME})
MESSAGE(STATUS "Adding ${FUNC_NAME} to MainApp")
SET(FUNC_LIBRARIES ${FUNC_LIBRARIES} ${FUNC_NAME})
SET(REGISTER_FUNCTIONALITY_DEFINITIONS "${REGISTER_FUNCTIONALITY_DEFINITIONS} 
  bool Register${FUNC_NAME}();"
)
SET(REGISTER_FUNCTIONALITY_CALLS "${REGISTER_FUNCTIONALITY_CALLS} 
  Register${FUNC_NAME}();"
)
ELSE(ALL_KNOWN_FUNCTIONALITY_NAMES MATCHES ${FUNC_NAME})
  MESSAGE(STATUS "WARNING: ${FUNC_NAME} has disappeared!")
  REMOVE_FROM_CACHE_LIST(MITK_FUNCTIONALITY_NAMES ${FUNC_NAME})
  REMOVE_FROM_CACHE_LIST(MBIQM_FUNCTIONALITY_NAMES ${FUNC_NAME})
  REMOVE_FROM_CACHE_LIST(MBISB_FUNCTIONALITY_NAMES ${FUNC_NAME})
ENDIF(ALL_KNOWN_FUNCTIONALITY_NAMES MATCHES ${FUNC_NAME})
ENDFOREACH(FUNC_NAME)


# now check for "internal" functionalities and register
# the right factory _before_ the functionalities
IF(MBISBFUNCTIONALITY_NAMES)
  SET(FACTORY_CLASS "SBCoreObjectFactory")
ELSE(MBISBFUNCTIONALITY_NAMES)
  IF(MBIQM_FUNCTIONALITY_NAMES)
    SET(FACTORY_CLASS "QMCoreObjectFactory")
  ELSE(MBIQM_FUNCTIONALITY_NAMES)
    SET(FACTORY_CLASS "")
  ENDIF(MBIQM_FUNCTIONALITY_NAMES)
ENDIF(MBISBFUNCTIONALITY_NAMES)
IF(FACTORY_CLASS)
  SET(REGISTER_FUNCTIONALITY_DEFINITIONS "void Register${FACTORY_CLASS}();
    ${REGISTER_FUNCTIONALITY_DEFINITIONS} 
    "
  )
  SET(REGISTER_FUNCTIONALITY_CALLS "Register${FACTORY_CLASS}();
     ${REGISTER_FUNCTIONALITY_CALLS} 
    "
  )
ENDIF(FACTORY_CLASS)

CONFIGURE_FILE(RegisterFunctionalityCalls.cpp.in ${CMAKE_CURRENT_BINARY_DIR}/RegisterFunctionalityCalls.cpp @ONLY)
# CONFIGURE_FILE(RegisterFunctionalityCalls.h.in RegisterFunctionalityCalls.h @ONLY)
INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR})
SET(REGISTER_FUNCTIONALITY_CALLS_CPP ${CMAKE_CURRENT_BINARY_DIR}/RegisterFunctionalityCalls.cpp)
SET(MAIN_APP_CPP SampleApp.cpp SampleAppMain.cpp ${REGISTER_FUNCTIONALITY_CALLS_CPP})
QT_WRAP_CPP(MainApp MAIN_APP_CPP SampleApp.h)

ADD_EXECUTABLE(MainApp ${MAIN_APP_CPP})
TARGET_LINK_LIBRARIES(MainApp Qmitk ${FUNC_LIBRARIES}) 

# tests without data
ADD_TEST(MainAppWithoutData ${EXECUTABLE_OUTPUT_PATH}/MainApp -testing)
IF(MITK_EXTENDED_APPLICATION_TESTING)
  FOREACH(FUNC_NAME ${FUNC_LIBRARIES})
    ADD_TEST(${FUNC_NAME}_WithoutData ${EXECUTABLE_OUTPUT_PATH}/MainApp -testing ${FUNC_NAME})
  ENDFOREACH(FUNC_NAME)
ENDIF(MITK_EXTENDED_APPLICATION_TESTING)

# now testwith all data files found
FILE(GLOB testdatalist ${MITK_SOURCE_DIR}/Testing/Data/*.*)
LIST(REMOVE_ITEM testdatalist "${MITK_SOURCE_DIR}/Testing/Data/.svn")
FOREACH(testdataitem ${testdatalist})
GET_FILENAME_COMPONENT(testdataname ${testdataitem} NAME)
IF(MITK_EXTENDED_APPLICATION_TESTING)
FOREACH(FUNC_NAME ${FUNC_LIBRARIES})
ADD_TEST(${FUNC_NAME}_${testdataname} ${EXECUTABLE_OUTPUT_PATH}/MainApp ${testdataitem} -testing ${FUNC_NAME})
ENDFOREACH(FUNC_NAME)
ENDIF(MITK_EXTENDED_APPLICATION_TESTING)
ADD_TEST(MainApp_${testdataname} ${EXECUTABLE_OUTPUT_PATH}/MainApp ${testdataitem} -testing)
ENDFOREACH(testdataitem)

IF(MITK_CHILI_PLUGIN)
   ADD_SUBDIRECTORY(ChiliPlugin)
ENDIF(MITK_CHILI_PLUGIN)


