####
FIND_PACKAGE(ITK)

IF(NOT MITK_KITNAME_FOR_MAINAPP)
  SET(MITK_KITNAME_FOR_MAINAPP MITK)
ENDIF(NOT MITK_KITNAME_FOR_MAINAPP)
FIND_PACKAGE(${MITK_KITNAME_FOR_MAINAPP})

# sometimes the APPLY_VTK_FLAGS call in MITKConfig.cmake is skipped by CMake, so
# make sure they're applied
APPLY_VTK_FLAGS()

SET(MITK_STARTUP_FUNCTIONALITY "QmitkSimpleExampleFunctionality" CACHE STRING "Name of first functionality in toolbar, activated at startup")
CONFIGURE_FILE(SampleAppConfig.h.in ${CMAKE_CURRENT_BINARY_DIR}/SampleAppConfig.h @ONLY)

INCLUDE_DIRECTORIES(${Q${MITK_KITNAME_FOR_MAINAPP}_INCLUDE_DIRS} ${CMAKE_CURRENT_BINARY_DIR})
LINK_DIRECTORIES(${MITK_LINK_DIRECTORIES})

SET(QT_MT_REQUIRED 1)
FIND_PACKAGE(Qt3)
ADD_DEFINITIONS(${QT_DEFINITIONS})

GET_DIRECTORY_PROPERTY(CACHE_VARS CACHE_VARIABLES)

FOREACH(kit MITK MBIQM MBISB)
  SET(${kit}_FUNCTIONALITY_NAMES_KNOWN "")

FOREACH(entry ${CACHE_VARS})
STRING(REGEX MATCH "^${kit}_KNOWN_FUNCTIONALITY_[A-Za-z0-9]+$" match ${entry})
IF(match)
  STRING(REGEX REPLACE "^${kit}_KNOWN_FUNCTIONALITY_" "" potential_func_name ${match})
  # now check whether a functionality dir is set and exists
  IF(${match})
    IF(IS_DIRECTORY ${${match}})
      SET(${kit}_FUNCTIONALITY_NAMES_KNOWN "${${kit}_FUNCTIONALITY_NAMES_KNOWN};${potential_func_name}")
    ENDIF(IS_DIRECTORY ${${match}})
  ENDIF(${match})
ENDIF(match)
ENDFOREACH(entry)
# MESSAGE("${kit}_FUNCTIONALITY_NAMES_KNOWN: ${${kit}_FUNCTIONALITY_NAMES_KNOWN}")
ENDFOREACH(kit)

# not needed at the moment since we have to distinguish between public and 
# mbi version, see comment below
# SET(ALL_KNOWN_FUNCTIONALITY_NAMES ${MBIQM_FUNCTIONALITY_NAMES_KNOWN} ${MBISB_FUNCTIONALITY_NAMES_KNOWN})

FOREACH(FUNC_NAME ${MITK_FUNCTIONALITY_NAMES_KNOWN})
  IF(BUILD_${FUNC_NAME} OR BUILD_ALL_FUNCTIONALITIES)
    MESSAGE(STATUS "Adding ${FUNC_NAME} to MainApp")
    SET(FUNC_LIBRARIES ${FUNC_LIBRARIES} ${FUNC_NAME})
    IF(WIN32 AND MITK_BUILD_SHARED_CORE)
      SET(FUNCTIONALITY_IMPORT "__declspec(dllimport)")
    ELSE(WIN32 AND MITK_BUILD_SHARED_CORE)
      SET(FUNCTIONALITY_IMPORT "")
    ENDIF(WIN32 AND MITK_BUILD_SHARED_CORE)
    SET(REGISTER_FUNCTIONALITY_DEFINITIONS "${REGISTER_FUNCTIONALITY_DEFINITIONS} 
      ${FUNCTIONALITY_IMPORT} bool Register${FUNC_NAME}();"
    )
    SET(REGISTER_FUNCTIONALITY_CALLS "${REGISTER_FUNCTIONALITY_CALLS} 
      Register${FUNC_NAME}();"
    )
    ENDIF(BUILD_${FUNC_NAME} OR BUILD_ALL_FUNCTIONALITIES)
ENDFOREACH(FUNC_NAME)

# This is the same as above, but QM and SB functionalities still depend on a 
# lot of static libs so we don't want them shared.
FOREACH(FUNC_NAME ${MBIQM_FUNCTIONALITY_NAMES_KNOWN} ${MBISB_FUNCTIONALITY_NAMES_KNOWN})
  IF(BUILD_${FUNC_NAME} OR BUILD_ALL_FUNCTIONALITIES)
    MESSAGE(STATUS "Adding ${FUNC_NAME} to MainApp")
    SET(FUNC_LIBRARIES ${FUNC_LIBRARIES} ${FUNC_NAME})
    SET(REGISTER_FUNCTIONALITY_DEFINITIONS "${REGISTER_FUNCTIONALITY_DEFINITIONS} 
      bool Register${FUNC_NAME}();"
    )
    SET(REGISTER_FUNCTIONALITY_CALLS "${REGISTER_FUNCTIONALITY_CALLS} 
      Register${FUNC_NAME}();"
    )
  ENDIF(BUILD_${FUNC_NAME} OR BUILD_ALL_FUNCTIONALITIES)
ENDFOREACH(FUNC_NAME)

OPTION(MITK_USE_QM_CLASSES "Force using QM factory and classes independent of functionality choice")
OPTION(MITK_USE_SB_CLASSES "Force using sandbox factory and classes independent of functionality choice")
MARK_AS_ADVANCED(MITK_USE_QM_CLASSES)
MARK_AS_ADVANCED(MITK_USE_SB_CLASSES)

# now check for "internal" functionalities and register
# the right factory _before_ the functionalities
IF(BUILD_ALL_FUNCTIONALITIES)
  # now we have to find out what kind of project we are
  IF(MBISB_FUNCTIONALITY_NAMES_KNOWN) 
    SET(FACTORY_CLASS "SBCoreObjectFactory")
    SET(QMITK_REGISTER_CALL "QmitkRegisterSBClasses()")
  ELSE(MBISB_FUNCTIONALITY_NAMES_KNOWN) 
    IF(MBIQM_FUNCTIONALITY_NAMES_KNOWN) 
      SET(FACTORY_CLASS "QMCoreObjectFactory")
      SET(QMITK_REGISTER_CALL "QmitkRegisterQMClasses()")
    ENDIF(MBIQM_FUNCTIONALITY_NAMES_KNOWN) 
  ENDIF(MBISB_FUNCTIONALITY_NAMES_KNOWN) 
ELSE(BUILD_ALL_FUNCTIONALITIES)  
  # find out which main dir has an enabled functionality
  SET(MBISB_IS_ON FALSE)
  FOREACH(FUNC_NAME ${MBISB_FUNCTIONALITY_NAMES_KNOWN})
    IF(BUILD_${FUNC_NAME})
       SET(MBISB_IS_ON TRUE)
    ENDIF(BUILD_${FUNC_NAME})
  ENDFOREACH(FUNC_NAME)
  IF(MBISB_IS_ON OR MITK_USE_SB_CLASSES)
    SET(FACTORY_CLASS "SBCoreObjectFactory")
    SET(QMITK_REGISTER_CALL "QmitkRegisterSBClasses()")
    SET(FUNC_LIBRARIES ${FUNC_LIBRARIES} Qmitk-mbi-sb mitkAlgorithms-mbi-sb)
  ELSE(MBISB_IS_ON OR MITK_USE_SB_CLASSES)
    SET(MBIQM_IS_ON FALSE)
    FOREACH(FUNC_NAME ${MBIQM_FUNCTIONALITY_NAMES_KNOWN})
      IF(BUILD_${FUNC_NAME})
       SET(MBIQM_IS_ON TRUE)
      ENDIF(BUILD_${FUNC_NAME})
    ENDFOREACH(FUNC_NAME)
    IF(MBIQM_IS_ON OR MITK_USE_QM_CLASSES)
        SET(FACTORY_CLASS "QMCoreObjectFactory")
        SET(QMITK_REGISTER_CALL "QmitkRegisterQMClasses()")
        SET(FUNC_LIBRARIES ${FUNC_LIBRARIES} Qmitk-mbi-qm mitkAlgorithms-mbi-qm)
    ELSE(MBIQM_IS_ON OR MITK_USE_QM_CLASSES)
        SET(FACTORY_CLASS "")
    ENDIF(MBIQM_IS_ON OR MITK_USE_QM_CLASSES)
  ENDIF(MBISB_IS_ON OR MITK_USE_SB_CLASSES)
ENDIF(BUILD_ALL_FUNCTIONALITIES)  
  
IF (NOT QMITK_REGISTER_CALL)
  SET(QMITK_REGISTER_CALL "QmitkRegisterClasses()")
ENDIF (NOT QMITK_REGISTER_CALL)

IF(FACTORY_CLASS)
  SET(REGISTER_FUNCTIONALITY_DEFINITIONS "void Register${FACTORY_CLASS}();
    void ${QMITK_REGISTER_CALL};
    ${REGISTER_FUNCTIONALITY_DEFINITIONS} 
    "
  )
  SET(REGISTER_FUNCTIONALITY_CALLS "Register${FACTORY_CLASS}();
    ${QMITK_REGISTER_CALL};
     ${REGISTER_FUNCTIONALITY_CALLS} 
    "
  )
ELSE(FACTORY_CLASS)
  SET(REGISTER_FUNCTIONALITY_DEFINITIONS "
    void ${QMITK_REGISTER_CALL};
    ${REGISTER_FUNCTIONALITY_DEFINITIONS} 
    "
  )
  SET(REGISTER_FUNCTIONALITY_CALLS "
    ${QMITK_REGISTER_CALL};
     ${REGISTER_FUNCTIONALITY_CALLS} 
    "
  )
ENDIF(FACTORY_CLASS)

CONFIGURE_FILE(RegisterFunctionalityCalls.cpp.in ${CMAKE_CURRENT_BINARY_DIR}/RegisterFunctionalityCalls.cpp @ONLY)
# CONFIGURE_FILE(RegisterFunctionalityCalls.h.in RegisterFunctionalityCalls.h @ONLY)
INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR})
SET(REGISTER_FUNCTIONALITY_CALLS_CPP ${CMAKE_CURRENT_BINARY_DIR}/RegisterFunctionalityCalls.cpp)
SET(MAIN_APP_CPP SampleApp.cpp SampleAppMain.cpp ${REGISTER_FUNCTIONALITY_CALLS_CPP})
QT_WRAP_CPP(MainApp MAIN_APP_CPP SampleApp.h)

ADD_EXECUTABLE(MainApp ${MAIN_APP_CPP})
TARGET_LINK_LIBRARIES(MainApp Qmitk ${FUNC_LIBRARIES}) 

INCLUDE(ApplicationTesting.cmake)

ADD_SUBDIRECTORY(ChiliPlugin)

INSTALL(TARGETS MainApp
   RUNTIME DESTINATION bin
   LIBRARY DESTINATION lib
   ARCHIVE DESTINATION lib/static)


SET(TOOL_EXTENSIONS_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../ToolExtensionsExample/)
SET(TOOL_EXTENSIONS_BUILD_DIR ${PROJECT_BINARY_DIR}/tmp-external-tools/)

IF(MBISB_FUNCTIONALITY_NAMES_KNOWN OR MBIQM_FUNCTIONALITY_NAMES_KNOWN) 
  SET(MITK_WHERE_COMPILE ${PROJECT_BINARY_DIR}/mitk)
ELSE(MBISB_FUNCTIONALITY_NAMES_KNOWN OR MBIQM_FUNCTIONALITY_NAMES_KNOWN) 
  SET(MITK_WHERE_COMPILE ${PROJECT_BINARY_DIR})
ENDIF(MBISB_FUNCTIONALITY_NAMES_KNOWN OR MBIQM_FUNCTIONALITY_NAMES_KNOWN)

# CMAKE_GENERATOR is provided by CMake
#ADD_TEST(mitkExternalToolsTestPart1
#         "echo '[ ! -d tmp-external-tools ] && mkdir' | bash"
#         "tmp-external-tools"
#        )
FILE(MAKE_DIRECTORY ${TOOL_EXTENSIONS_BUILD_DIR})

ADD_TEST(mitkExternalToolsTestPart1Configure
         "${CMAKE_COMMAND}" 
         "-E"
         "chdir"
         "${TOOL_EXTENSIONS_BUILD_DIR}"
         "${CMAKE_COMMAND}" 
         "-G"
         "${CMAKE_GENERATOR}" 
         "-DMITK_DIR:PATH=${MITK_WHERE_COMPILE}"
         "${TOOL_EXTENSIONS_SOURCE_DIR}"
        )

IF (NOT WIN32)
ADD_TEST(mitkExternalToolsTestPart2Build
         "${CMAKE_COMMAND}" 
         "-E"
         "chdir"
         "${TOOL_EXTENSIONS_BUILD_DIR}"
         "make"
        )
ENDIF (NOT WIN32)

