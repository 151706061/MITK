####
FIND_PACKAGE(ITK)

IF(NOT MITK_KITNAME_FOR_MAINAPP)
  SET(MITK_KITNAME_FOR_MAINAPP MITK)
ENDIF(NOT MITK_KITNAME_FOR_MAINAPP)
FIND_PACKAGE(${MITK_KITNAME_FOR_MAINAPP})

# sometimes the APPLY_VTK_FLAGS call in MITKConfig.cmake is skipped by CMake, so
# make sure they're applied
APPLY_VTK_FLAGS()

INCLUDE_DIRECTORIES(${Q${MITK_KITNAME_FOR_MAINAPP}_INCLUDE_DIRS})
LINK_DIRECTORIES(${MITK_LINK_DIRECTORIES})

SET(QT_MT_REQUIRED 1)
FIND_PACKAGE(Qt3)
ADD_DEFINITIONS(${QT_DEFINITIONS})

GET_DIRECTORY_PROPERTY(CACHE_VARS CACHE_VARIABLES)

FOREACH(kit MITK MBIQM MBISB)
  SET(${kit}_FUNCTIONALITY_NAMES_KNOWN "")

FOREACH(entry ${CACHE_VARS})
STRING(REGEX MATCH "^${kit}_KNOWN_FUNCTIONALITY_[A-Za-z0-9]+$" match ${entry})
IF(match)
  STRING(REGEX REPLACE "^${kit}_KNOWN_FUNCTIONALITY_" "" potential_func_name ${match})
  # now check whether a functionality dir is set and exists
  IF(${match})
    IF(IS_DIRECTORY ${${match}})
      SET(${kit}_FUNCTIONALITY_NAMES_KNOWN "${${kit}_FUNCTIONALITY_NAMES_KNOWN};${potential_func_name}")
    ENDIF(IS_DIRECTORY ${${match}})
  ENDIF(${match})
ENDIF(match)
ENDFOREACH(entry)
# MESSAGE("${kit}_FUNCTIONALITY_NAMES_KNOWN: ${${kit}_FUNCTIONALITY_NAMES_KNOWN}")
ENDFOREACH(kit)

# not needed at the moment since we have to distinguish between public and 
# mbi version, see comment below
# SET(ALL_KNOWN_FUNCTIONALITY_NAMES ${MBIQM_FUNCTIONALITY_NAMES_KNOWN} ${MBISB_FUNCTIONALITY_NAMES_KNOWN})

FOREACH(FUNC_NAME ${MITK_FUNCTIONALITY_NAMES_KNOWN})
  IF(BUILD_${FUNC_NAME} OR BUILD_ALL_FUNCTIONALITIES)
    MESSAGE(STATUS "Adding ${FUNC_NAME} to MainApp")
    SET(FUNC_LIBRARIES ${FUNC_LIBRARIES} ${FUNC_NAME})
    IF(WIN32 AND MITK_BUILD_SHARED_CORE)
      SET(FUNCTIONALITY_IMPORT "__declspec(dllimport)")
    ELSE(WIN32 AND MITK_BUILD_SHARED_CORE)
      SET(FUNCTIONALITY_IMPORT "")
    ENDIF(WIN32 AND MITK_BUILD_SHARED_CORE)
    SET(REGISTER_FUNCTIONALITY_DEFINITIONS "${REGISTER_FUNCTIONALITY_DEFINITIONS} 
      ${FUNCTIONALITY_IMPORT} bool Register${FUNC_NAME}();"
    )
    SET(REGISTER_FUNCTIONALITY_CALLS "${REGISTER_FUNCTIONALITY_CALLS} 
      Register${FUNC_NAME}();"
    )
    ENDIF(BUILD_${FUNC_NAME} OR BUILD_ALL_FUNCTIONALITIES)
ENDFOREACH(FUNC_NAME)

# This is the same as above, but QM and SB functionalities still depend on a 
# lot of static libs so we don't want them shared.
FOREACH(FUNC_NAME ${MBIQM_FUNCTIONALITY_NAMES_KNOWN} ${MBISB_FUNCTIONALITY_NAMES_KNOWN})
  IF(BUILD_${FUNC_NAME} OR BUILD_ALL_FUNCTIONALITIES)
    MESSAGE(STATUS "Adding ${FUNC_NAME} to MainApp")
    SET(FUNC_LIBRARIES ${FUNC_LIBRARIES} ${FUNC_NAME})
    SET(REGISTER_FUNCTIONALITY_DEFINITIONS "${REGISTER_FUNCTIONALITY_DEFINITIONS} 
      bool Register${FUNC_NAME}();"
    )
    SET(REGISTER_FUNCTIONALITY_CALLS "${REGISTER_FUNCTIONALITY_CALLS} 
      Register${FUNC_NAME}();"
    )
  ENDIF(BUILD_${FUNC_NAME} OR BUILD_ALL_FUNCTIONALITIES)
ENDFOREACH(FUNC_NAME)


# now check for "internal" functionalities and register
# the right factory _before_ the functionalities
IF(BUILD_ALL_FUNCTIONALITIES)
  # now we have to find out what kind of project we are
  IF(MBISB_FUNCTIONALITY_NAMES_KNOWN) 
    SET(FACTORY_CLASS "SBCoreObjectFactory")
    SET(QMITK_REGISTER_CALL "QmitkRegisterSBClasses()")
  ELSE(MBISB_FUNCTIONALITY_NAMES_KNOWN) 
    IF(MBIQM_FUNCTIONALITY_NAMES_KNOWN) 
      SET(FACTORY_CLASS "QMCoreObjectFactory")
      SET(QMITK_REGISTER_CALL "QmitkRegisterQMClasses()")
    ENDIF(MBIQM_FUNCTIONALITY_NAMES_KNOWN) 
  ENDIF(MBISB_FUNCTIONALITY_NAMES_KNOWN) 
ELSE(BUILD_ALL_FUNCTIONALITIES)  
  # find out which main dir has an enabled functionality
  SET(MBISB_IS_ON FALSE)
  FOREACH(FUNC_NAME ${MBISB_FUNCTIONALITY_NAMES_KNOWN})
    IF(BUILD_${FUNC_NAME})
       SET(MBISB_IS_ON TRUE)
    ENDIF(BUILD_${FUNC_NAME})
  ENDFOREACH(FUNC_NAME)
  IF(MBISB_IS_ON)
    SET(FACTORY_CLASS "SBCoreObjectFactory")
    SET(QMITK_REGISTER_CALL "QmitkRegisterSBClasses()")
  ELSE(MBISB_IS_ON)
    SET(MBIQM_IS_ON FALSE)
    FOREACH(FUNC_NAME ${MBIQM_FUNCTIONALITY_NAMES_KNOWN})
      IF(BUILD_${FUNC_NAME})
       SET(MBIQM_IS_ON TRUE)
      ENDIF(BUILD_${FUNC_NAME})
    ENDFOREACH(FUNC_NAME)
    IF(MBIQM_IS_ON)
        SET(FACTORY_CLASS "QMCoreObjectFactory")
        SET(QMITK_REGISTER_CALL "QmitkRegisterQMClasses()")
    ELSE(MBIQM_IS_ON)
        SET(FACTORY_CLASS "")
    ENDIF(MBIQM_IS_ON)
  ENDIF(MBISB_IS_ON)
ENDIF(BUILD_ALL_FUNCTIONALITIES)  
  
IF (NOT QMITK_REGISTER_CALL)
  SET(QMITK_REGISTER_CALL "QmitkRegisterClasses()")
ENDIF (NOT QMITK_REGISTER_CALL)

IF(FACTORY_CLASS)
  SET(REGISTER_FUNCTIONALITY_DEFINITIONS "void Register${FACTORY_CLASS}();
    void ${QMITK_REGISTER_CALL};
    ${REGISTER_FUNCTIONALITY_DEFINITIONS} 
    "
  )
  SET(REGISTER_FUNCTIONALITY_CALLS "Register${FACTORY_CLASS}();
    ${QMITK_REGISTER_CALL};
     ${REGISTER_FUNCTIONALITY_CALLS} 
    "
  )
ELSE(FACTORY_CLASS)
  SET(REGISTER_FUNCTIONALITY_DEFINITIONS "
    void ${QMITK_REGISTER_CALL};
    ${REGISTER_FUNCTIONALITY_DEFINITIONS} 
    "
  )
  SET(REGISTER_FUNCTIONALITY_CALLS "
    ${QMITK_REGISTER_CALL};
     ${REGISTER_FUNCTIONALITY_CALLS} 
    "
  )
ENDIF(FACTORY_CLASS)

CONFIGURE_FILE(RegisterFunctionalityCalls.cpp.in ${CMAKE_CURRENT_BINARY_DIR}/RegisterFunctionalityCalls.cpp @ONLY)
# CONFIGURE_FILE(RegisterFunctionalityCalls.h.in RegisterFunctionalityCalls.h @ONLY)
INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR})
SET(REGISTER_FUNCTIONALITY_CALLS_CPP ${CMAKE_CURRENT_BINARY_DIR}/RegisterFunctionalityCalls.cpp)
SET(MAIN_APP_CPP SampleApp.cpp SampleAppMain.cpp ${REGISTER_FUNCTIONALITY_CALLS_CPP})
QT_WRAP_CPP(MainApp MAIN_APP_CPP SampleApp.h)

ADD_EXECUTABLE(MainApp ${MAIN_APP_CPP})
TARGET_LINK_LIBRARIES(MainApp Qmitk ${FUNC_LIBRARIES}) 

# tests without data
IF(MITK_APPLICATION_TESTING)
  ADD_TEST(MainAppWithoutData ${EXECUTABLE_OUTPUT_PATH}/MainApp -noMITKOptions -testing)
  ADD_TEST(MainApp_EmptyImage ${EXECUTABLE_OUTPUT_PATH}/MainApp -testEmptyImage -noMITKOptions -testing)
  ADD_TEST(MainApp_EmptySurface ${EXECUTABLE_OUTPUT_PATH}/MainApp -testEmptySurface -noMITKOptions -testing)
  ADD_TEST(MainApp_EmptyPointSet ${EXECUTABLE_OUTPUT_PATH}/MainApp -testEmptyPointSet -noMITKOptions -testing)
  ADD_TEST(MainApp_EmptyNode ${EXECUTABLE_OUTPUT_PATH}/MainApp -testEmptyNode -noMITKOptions -testing)
ENDIF(MITK_APPLICATION_TESTING)
IF(MITK_FUNCTIONALITY_TESTING)
  FOREACH(FUNC_NAME ${FUNC_LIBRARIES})
    ADD_TEST(${FUNC_NAME}_WithoutData ${EXECUTABLE_OUTPUT_PATH}/MainApp -noMITKOptions -testing ${FUNC_NAME})
    ADD_TEST(${FUNC_NAME}_EmptyImage ${EXECUTABLE_OUTPUT_PATH}/MainApp -testEmptyImage -noMITKOptions -testing ${FUNC_NAME})
    ADD_TEST(${FUNC_NAME}_EmptySurface ${EXECUTABLE_OUTPUT_PATH}/MainApp -testEmptySurface -noMITKOptions -testing ${FUNC_NAME})
    ADD_TEST(${FUNC_NAME}_EmptyPointSet ${EXECUTABLE_OUTPUT_PATH}/MainApp -testEmptyPointSet -noMITKOptions -testing ${FUNC_NAME})
    ADD_TEST(${FUNC_NAME}_EmptyNode ${EXECUTABLE_OUTPUT_PATH}/MainApp -testEmptyNode -noMITKOptions -testing ${FUNC_NAME})
  ENDFOREACH(FUNC_NAME)
ENDIF(MITK_FUNCTIONALITY_TESTING)

# now test with all data files found
FILE(GLOB testdatalist ${MITK_SOURCE_DIR}/Testing/Data/*.*)
LIST(REMOVE_ITEM testdatalist "${MITK_SOURCE_DIR}/Testing/Data/.svn")
FOREACH(testdataitem ${testdatalist})

  GET_FILENAME_COMPONENT(testdataname ${testdataitem} NAME)

  IF(MITK_FUNCTIONALITY_TESTING)
    FOREACH(FUNC_NAME ${FUNC_LIBRARIES})
    ADD_TEST(${FUNC_NAME}_${testdataname} ${EXECUTABLE_OUTPUT_PATH}/MainApp ${testdataitem} -noMITKOptions -testing ${FUNC_NAME})
    ENDFOREACH(FUNC_NAME)
  ENDIF(MITK_FUNCTIONALITY_TESTING)

  IF(MITK_APPLICATION_TESTING)
    ADD_TEST(MainApp_${testdataname} ${EXECUTABLE_OUTPUT_PATH}/MainApp ${testdataitem} -noMITKOptions -testing)
  ENDIF(MITK_APPLICATION_TESTING)

ENDFOREACH(testdataitem)

ADD_SUBDIRECTORY(ChiliPlugin)

INSTALL(TARGETS MainApp
   RUNTIME DESTINATION bin
   LIBRARY DESTINATION lib
   ARCHIVE DESTINATION lib/static)

  

