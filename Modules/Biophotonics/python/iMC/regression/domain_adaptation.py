'''
Created on Oct 20, 2015

@author: wirkert
'''

import numpy as np
from sklearn.cross_validation import KFold
from sklearn.grid_search import GridSearchCV
from sklearn.linear_model import LogisticRegression

def estimate_logistic_regressor(X_s, X_t):
    """ estimate a logistic regressor to predict the probability of a sample
    to be generated by one class or the other.
    If one class is over or under represented weights will be adapted.

    Parameters:
        X_s: samples from the source domain
        X_t: samples from the target domain

    Returns:
        Linear regressor which predicts the probability of a new sample to
        belong to the source domain """
    nr_s = X_s.shape[0]
    nr_t = X_t.shape[0]
    source_labels = np.zeros(nr_s)
    target_labels = np.ones(nr_t)
    X_all = np.concatenate((X_s, X_t))
    all_labels = np.concatenate((source_labels, target_labels))

    # train logistic regression
    kf = KFold(X_all.shape[0], 10, shuffle=True)
    # todo include intercept scaling paramter
    param_grid = [
      {'C': np.logspace(-3, 6, 10), 'fit_intercept':['True', 'False']} ]
    best_lr = GridSearchCV(LogisticRegression(class_weight="auto"),
                           param_grid, cv=kf, n_jobs=-1)
    best_lr.fit(X_all, all_labels)

    return best_lr.best_estimator_

def resample(X, y, w, nr_samples=None):
    """bootstrapping: resample with replacement according to weights

    Returns:
        (X_new, w_new): the chosen samples and the new weights.
            by design these new weights are all equal to 1."""
    if (nr_samples is None):
        nr_samples = X.shape[0]
    w = w / np.sum(w)  # normalize
    # create index array with samples to draw:
    total_nr_samples = X.shape[0]  # nr total samples
    chosen_samples = np.random.choice(total_nr_samples,
                                      size=nr_samples,
                                      replace=True, p=w)
    if y.ndim == 1:
        y_chosen = y[chosen_samples]
    else:
        y_chosen = y[chosen_samples, :]
    return X[chosen_samples, :], y_chosen, np.ones(nr_samples)
