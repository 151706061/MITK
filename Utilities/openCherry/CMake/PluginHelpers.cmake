
MACRO(COLLECT_PLUGINS BUILD_ALL_PLUGINS ADD_TO_PLUGIN_DIRS)

# Collect plugin directories
FILE(GLOB PLUGIN_DIRS RELATIVE ${CMAKE_CURRENT_SOURCE_DIR} *)
LIST(REMOVE_ITEM PLUGIN_DIRS 
  "CVS" 
  ".svn"
  "CMake"
)

FOREACH(RELATIVE_PLUGIN_PATH ${PLUGIN_DIRS})
  SET(FULL_PLUGIN_PATH ${CMAKE_CURRENT_SOURCE_DIR}/${RELATIVE_PLUGIN_PATH})
  IF(IS_DIRECTORY ${FULL_PLUGIN_PATH})
    IF(EXISTS ${FULL_PLUGIN_PATH}/CMakeLists.txt)
      MESSAGE(STATUS "Processing ${FULL_PLUGIN_PATH}")
      OPTION("BUILD_${RELATIVE_PLUGIN_PATH}" "Build ${RELATIVE_PLUGIN_PATH} Plugin" ON)
      IF(BUILD_${RELATIVE_PLUGIN_PATH} OR BUILD_ALL_PLUGINS)
        ADD_SUBDIRECTORY(${FULL_PLUGIN_PATH})
      ENDIF(BUILD_${RELATIVE_PLUGIN_PATH} OR BUILD_ALL_PLUGINS)
    ELSE(EXISTS ${FULL_PLUGIN_PATH}/CMakeLists.txt)
      MESSAGE("Plugin dir ${FULL_PLUGIN_PATH} doesn't contain a CMakeLists.txt file")
    ENDIF(EXISTS ${FULL_PLUGIN_PATH}/CMakeLists.txt)
  ENDIF(IS_DIRECTORY ${FULL_PLUGIN_PATH})
ENDFOREACH(RELATIVE_PLUGIN_PATH)

IF(ADD_TO_PLUGIN_DIRS)
  SET(MATCHED_DIR 0)
  IF(${OPENCHERRY_PLUGIN_DIRS} MATCHES ${CMAKE_CURRENT_BINARY_DIR})
    SET(MATCHED_DIR 1)
  ENDIF(${OPENCHERRY_PLUGIN_DIRS} MATCHES ${CMAKE_CURRENT_BINARY_DIR})

  IF(NOT MATCHED_DIR)
    SET(OPENCHERRY_PLUGIN_DIRS "${OPENCHERRY_PLUGIN_DIRS},${CMAKE_CURRENT_BINARY_DIR}"
        CACHE STRING "A comma-separated list of directories containing plugins" FORCE)
  ENDIF(NOT MATCHED_DIR)
ENDIF(ADD_TO_PLUGIN_DIRS)

ENDMACRO(COLLECT_PLUGINS)


# 
# Variables
#
#   PLUGIN_NAME: Name of the plugin. If not set it will be set to the directory name
# 
MACRO(CREATE_PLUGIN PLUGIN_NAME)
  SUPPRESS_VC8_DEPRECATED_WARNINGS()
  IF(NOT PLUGIN_NAME)
    GET_FILENAME_COMPONENT(PLUGIN_NAME ${PROJECT_SOURCE_DIR} NAME)
    MESSAGE(STATUS "Warning. No PLUGIN_NAME set. Setting it to directory name: ${PLUGIN_NAME}")
  ENDIF(NOT PLUGIN_NAME)
  STRING(REPLACE . _ PLUGIN_TARGET ${PLUGIN_NAME})
  
  IF(NOT PLUGIN_CPP)
    MESSAGE(STATUS "Using files.cmake for plugin ${PLUGIN_NAME}")
    INCLUDE(files.cmake)
    SET(PLUGIN_CPP ${CPP_FILES})
    SET(PLUGIN_MOC_H ${MOC_H_FILES})
    SET(PLUGIN_FORMS ${UI_FILES})
  ELSE(NOT PLUGIN_CPP)
    MESSAGE(STATUS "Using PLUGIN_CPP for plugin ${PLUGIN_NAME}")
  ENDIF(NOT PLUGIN_CPP)
  
  SET (LIBRARY_OUTPUT_PATH ${CMAKE_CURRENT_BINARY_DIR}/bin)
  CONFIGURE_FILE(${CMAKE_CURRENT_SOURCE_DIR}/META-INF/MANIFEST.MF ${CMAKE_CURRENT_BINARY_DIR}/META-INF/MANIFEST.MF COPYONLY)
  
  SET(PLUGINXML ${CMAKE_CURRENT_SOURCE_DIR}/plugin.xml)
  IF(EXISTS ${PLUGINXML})
    CONFIGURE_FILE(${PLUGINXML} ${CMAKE_CURRENT_BINARY_DIR}/plugin.xml COPYONLY)
  ENDIF(EXISTS ${PLUGINXML})

  SET(PLUGIN_CPP_LIST ${PLUGIN_CPP})
  IF(PLUGIN_FORMS)
    QT4_WRAP_UI(PLUGIN_CPP_LIST ${PLUGIN_FORMS})
  ENDIF(PLUGIN_FORMS)
  IF(PLUGIN_MOC_H)
    QT4_WRAP_CPP(PLUGIN_CPP_LIST ${PLUGIN_MOC_H})
  ENDIF(PLUGIN_MOC_H)
  INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_BINARY_DIR})
  
  IF(OPENCHERRY_STATIC)
    ADD_LIBRARY(${PLUGIN_TARGET} STATIC ${PLUGIN_CPP_LIST})
  ELSE(OPENCHERRY_STATIC)
    ADD_LIBRARY(${PLUGIN_TARGET} SHARED ${PLUGIN_CPP_LIST})
    #SET_TARGET_PROPERTIES(${PLUGIN_TARGET} PROPERTIES DEFINE_SYMBOL CHERRY_EXPORTS)
    IF(PLUGIN_REQUIRED_LIBS)
      TARGET_LINK_LIBRARIES(${PLUGIN_TARGET} ${PLUGIN_REQUIRED_LIBS})
    ENDIF(PLUGIN_REQUIRED_LIBS)
  ENDIF(OPENCHERRY_STATIC)

ENDMACRO(CREATE_PLUGIN)


# Macro to set specific Qt options, calls CREATE_PLUGIN at the end
MACRO(CREATE_QT_PLUGIN PLUGIN_NAME)
  
  IF(USE_QT AND DESIRED_QT_VERSION EQUAL 4)
    INCLUDE_DIRECTORIES(${QT_INCLUDES})
    ADD_DEFINITIONS(${QT_DEFINITIONS})
  
    SET(PLUGIN_REQUIRED_LIBS
      ${PLUGIN_REQUIRED_LIBS}
      ${QT_LIBRARIES}
    )
  
    CREATE_PLUGIN(${PLUGIN_NAME})
  ENDIF(USE_QT AND DESIRED_QT_VERSION EQUAL 4)
  
ENDMACRO(CREATE_QT_PLUGIN)

