diff --git a/Modules/ThirdParty/VNL/src/vxl/CMakeLists.txt b/Modules/ThirdParty/VNL/src/vxl/CMakeLists.txt
index 2b85b7bc79..4c66ee43b4 100644
--- a/Modules/ThirdParty/VNL/src/vxl/CMakeLists.txt
+++ b/Modules/ThirdParty/VNL/src/vxl/CMakeLists.txt
@@ -12,26 +12,51 @@
 # Root vxl
 #
 #   vxl-maintainers@lists.sf.net
-cmake_minimum_required(VERSION 2.8.9 FATAL_ERROR)
-
-# Set policies for cmake
-if( POLICY CMP0003 )
-  cmake_policy(SET CMP0003 NEW)
-endif()
-# Use @rpath on OS X
-if( POLICY CMP0042 )
-  cmake_policy(SET CMP0042 NEW)
+if( "${CMAKE_CXX_STANDARD}" MATCHES "(11|14|17|20)")
+   # If building for modern C++ language standards,
+   # require use of newer cmake version
+   cmake_minimum_required(VERSION 3.9.5 FATAL_ERROR)
+else()
+   cmake_minimum_required(VERSION 3.3.0 FATAL_ERROR)
 endif()
+# Set policies consistent with newer versions of cmake
+# to ease integration with projects that require newer
+# cmake versions.
+
+foreach(p
+    ## Only policies introduced after the cmake_minimum_required
+    ## version need to explicitly be set to NEW.
+
+    ##----- Policies Introduced by CMake 3.10Â¶
+    CMP0071  #: Let AUTOMOC and AUTOUIC process GENERATED files.
+    CMP0070  #: Define file(GENERATE) behavior for relative paths.
+    ##----- Policies Introduced by CMake 3.9
+    CMP0069  #: INTERPROCEDURAL_OPTIMIZATION is enforced when enabled.
+    CMP0068  #: RPATH settings on macOS do not affect install_name.
+    ##----- Policies Introduced by CMake 3.8
+    CMP0067  #: Honor language standard in try_compile() source-file signature.
+    ##----- Policies Introduced by CMake 3.7
+    CMP0066  #: Honor per-config flags in try_compile() source-file signature.
+    ##----- Policies Introduced by CMake 3.4
+    CMP0065  #: Do not add flags to export symbols from executables without the ENABLE_EXPORTS target property.
+    CMP0064  #: Support new TEST if() operator.
+    )
+  if(POLICY ${p})
+    cmake_policy(SET ${p} NEW)
+  endif()
+endforeach()
 
-# Honor visibility properties for static libraries
-if( POLICY CMP0063 )
-  cmake_policy(SET CMP0063 NEW)
-endif()
 
 project(vxl)
 
 include(CMakeDependentOption)
 
+#Disable overzealous compiler warning.  If the definition is truely missing a link error will be created.
+include(CheckCXXCompilerFlag)
+CHECK_CXX_COMPILER_FLAG(-Wno-undefined-var-template HAS_NO_UNDEFINED_VAR_TEMPLATE)
+if( HAS_NO_UNDEFINED_VAR_TEMPLATE )
+  add_definitions( -Wno-undefined-var-template )
+endif()
 
 find_program( MEMORYCHECK_COMMAND valgrind )
 if(MEMORYCHECK_COMMAND)
@@ -113,6 +138,7 @@ option(VXL_LEGACY_ERROR_REPORTING "Use old error reporting methods rather than e
 if(VXL_LEGACY_ERROR_REPORTING)
   add_definitions( -DVXL_LEGACY_ERROR_REPORTING )
 endif()
+option(VXL_RUN_FAILING_TESTS "Enable long-time failing tests. If tests are failing for a long time, turn them off by default." OFF)
 
 # Option to build Windows Unicode support, the string
 # type of which is wchar_t, each character is a 16-bit unsigned integer.
@@ -232,7 +258,7 @@ add_subdirectory(core)
 
 # Optionally build the contributed libraries
 if( EXISTS ${CMAKE_CURRENT_LIST_DIR}/contrib/CMakeLists.txt )
-  CMAKE_DEPENDENT_OPTION(BUILD_CONTRIB "Build the contributed libraries?" ON "BUILD_CORE_GEOMETRY;BUILD_CORE_NUMERICS;BUILD_CORE_UTILITIES;BUILD_CORE_SERIALISATION;BUILD_CORE_IMAGING" OFF)
+  CMAKE_DEPENDENT_OPTION(BUILD_CONTRIB "Build the contributed libraries?" OFF "BUILD_CORE_GEOMETRY;BUILD_CORE_NUMERICS;BUILD_CORE_UTILITIES;BUILD_CORE_SERIALISATION;BUILD_CORE_IMAGING" OFF)
   add_subdirectory(contrib)
 endif()
 
diff --git a/Modules/ThirdParty/VNL/src/vxl/CTestConfig.cmake b/Modules/ThirdParty/VNL/src/vxl/CTestConfig.cmake
deleted file mode 100644
index f2620f7bf6..0000000000
--- a/Modules/ThirdParty/VNL/src/vxl/CTestConfig.cmake
+++ /dev/null
@@ -1,8 +0,0 @@
-# CTest Configuration for VXL
-set(CTEST_PROJECT_NAME "VXL")
-set(CTEST_NIGHTLY_START_TIME "22:00:00 EST")
-
-set(CTEST_DROP_METHOD "http")
-set(CTEST_DROP_SITE "open.cdash.org")
-set(CTEST_DROP_LOCATION "/submit.php?project=vxl")
-set(CTEST_DROP_SITE_CDASH TRUE)
diff --git a/Modules/ThirdParty/VNL/src/vxl/config/cmake/Modules/FindClipper.cmake b/Modules/ThirdParty/VNL/src/vxl/config/cmake/Modules/FindClipper.cmake
new file mode 100644
index 0000000000..ad941254ff
--- /dev/null
+++ b/Modules/ThirdParty/VNL/src/vxl/config/cmake/Modules/FindClipper.cmake
@@ -0,0 +1,41 @@
+#
+# Find a CLIPPER library
+#
+# This file is used to manage using either a natively provided CLIPPER library or the one in v3p if provided.
+#
+#
+# As per the standard scheme the following definitions are used
+# CLIPPER_INCLUDE_DIR - where to find clipper.hxx
+# CLIPPER_LIBRARIES   - the set of libraries to include to use CLIPPER.
+# CLIPPER_FOUND       - TRUE, if available somewhere on the system.
+
+# Additionally
+# VXL_USING_NATIVE_CLIPPER  - True if we are using a CLIPPER library provided outside vxl (or v3p)
+
+if( NOT CLIPPER_FOUND )
+
+  # If this FORCE variable is unset or is FALSE, try to find a native library.
+  if( NOT VXL_FORCE_V3P_CLIPPER )
+    # ./FindGEOTIFF.cmake does this instead...
+    #include( ${MODULE_PATH}/NewCMake/FindGEOTIFF.cmake )
+    find_package( CLIPPER QUIET )
+    if( CLIPPER_FOUND )
+      set(VXL_USING_NATIVE_CLIPPER "YES")
+    endif()
+  endif()
+
+  #
+  # At some point, in a "release" version, it is possible that someone
+  # will not have the v3p clipper library, so make sure the headers
+  # exist.
+  #
+  if( NOT CLIPPER_FOUND )
+    if(EXISTS ${VXL_ROOT_SOURCE_DIR}/v3p/clipper/clipper.h)
+      set( CLIPPER_FOUND "YES" )
+      set( CLIPPER_INCLUDE_DIR ${clipper_BINARY_DIR} ${clipper_SOURCE_DIR})
+      set( CLIPPER_INSTALL_INCLUDE_DIR ${CMAKE_INSTALL_DIR}/include/vxl/v3p/clipper)
+      set( CLIPPER_LIBRARIES clipper )
+    endif()
+  endif()
+
+endif()
diff --git a/Modules/ThirdParty/VNL/src/vxl/config/cmake/Modules/NewCMake/FindOpenCL.cmake b/Modules/ThirdParty/VNL/src/vxl/config/cmake/Modules/NewCMake/FindOpenCL.cmake
index 69e9ea9371..9ba8283a63 100644
--- a/Modules/ThirdParty/VNL/src/vxl/config/cmake/Modules/NewCMake/FindOpenCL.cmake
+++ b/Modules/ThirdParty/VNL/src/vxl/config/cmake/Modules/NewCMake/FindOpenCL.cmake
@@ -69,9 +69,11 @@ if(APPLE)
 endif()
 
 if(UNIX)
-  find_path( OPENCL_INCLUDE_PATH CL/cl_gl.h PATHS /usr/include /usr/include/nvidia-current /usr/local/cuda/include)
-  find_path(OPENCL_LIBRARY_PATH libOpenCL.so PATHS /usr/lib /usr/lib/nvidia-current /usr/local/cuda/lib64 ${OPENCL_LIBRARY_PATH} )
-  find_library(OPENCL_LIBRARIES NAMES libOpenCL.so PATHS /usr/lib /usr/lib/nvidia-current ${OPENCL_LIBRARY_PATH} )
+  file(GLOB AMD_DIR /opt/AMDAPPSDK-*/include)
+  find_path( OPENCL_INCLUDE_PATH CL/cl_gl.h PATHS /usr/include /usr/include/nvidia-current /usr/local/cuda/include HINTS ${AMD_DIR})
+  file(GLOB AMD_DIR /opt/AMDAPPSDK-*/lib/x86_64/sdk /opt/AMDAPPSDK-*/lib/x86_64)
+  find_path(OPENCL_LIBRARY_PATH libOpenCL.so PATHS /usr/lib /usr/lib64 /usr/lib/nvidia-current /usr/local/cuda/lib64 ${OPENCL_LIBRARY_PATH} HINTS ${AMD_DIR} )
+  find_library(OPENCL_LIBRARIES NAMES libOpenCL.so PATHS /usr/lib /usr/lib64 /usr/lib/nvidia-current ${OPENCL_LIBRARY_PATH} )
   if(OPENCL_INCLUDE_PATH)
       if(OPENCL_LIBRARIES)
         set(OPENCL_FOUND "YES")
diff --git a/Modules/ThirdParty/VNL/src/vxl/config/cmake/Modules/NewCMake/readme.txt b/Modules/ThirdParty/VNL/src/vxl/config/cmake/Modules/NewCMake/readme.txt
index b69c359257..9387e9b15c 100644
--- a/Modules/ThirdParty/VNL/src/vxl/config/cmake/Modules/NewCMake/readme.txt
+++ b/Modules/ThirdParty/VNL/src/vxl/config/cmake/Modules/NewCMake/readme.txt
@@ -5,9 +5,9 @@ To facilitate the deprecation of modules, place code similar to the
 following in the FindXXX.cmake as soon as it becomes part of a CMake
 release:
 
-# FIXME: When cmake_minimum_version reaches 2.6.2 the FindXXX
+# FIXME: When cmake_minimum_version reaches 3.3.0 the FindXXX
 #        module in this directory is not needed anymore.
-IF(CMAKE_MINIMUM_REQUIRED_VERSION GREATER 2.6.1)
+IF(CMAKE_MINIMUM_REQUIRED_VERSION GREATER 3.3.0)
   MESSAGE(FATAL_ERROR
     "FindXXX not needed in vxl; it is now available in CMake.")
-ENDIF(CMAKE_MINIMUM_REQUIRED_VERSION GREATER 2.6.1)
+ENDIF(CMAKE_MINIMUM_REQUIRED_VERSION GREATER 3.3.0)
diff --git a/Modules/ThirdParty/VNL/src/vxl/config/cmake/Modules/VXLGenerateExportHeader.cmake b/Modules/ThirdParty/VNL/src/vxl/config/cmake/Modules/VXLGenerateExportHeader.cmake
index b0d7dd49cd..ad54658342 100644
--- a/Modules/ThirdParty/VNL/src/vxl/config/cmake/Modules/VXLGenerateExportHeader.cmake
+++ b/Modules/ThirdParty/VNL/src/vxl/config/cmake/Modules/VXLGenerateExportHeader.cmake
@@ -1,13 +1,5 @@
-# This version of GenerateExportHeader extends CMake's version to provide the
-# <module-name>_TEMPLATE_EXPORT macro. For templated class declarations, Windows
-# must not have the export specification, while GCC must have the export
-# specification.
-#
-# This macro is for templates with explicit instantiations built into a library.
-#
-# To avoid inadvertently overriding CMake's or another package's
-# GenerateExportHeader, this version is named differently and adds a prefix to
-# all global identifiers.
+# Distributed under the OSI-approved BSD 3-Clause License.  See accompanying
+# file Copyright.txt or https://cmake.org/licensing for details.
 
 #.rst:
 # VXLGenerateExportHeader
@@ -28,10 +20,12 @@
 #              [EXPORT_FILE_NAME <export_file_name>]
 #              [DEPRECATED_MACRO_NAME <deprecated_macro_name>]
 #              [NO_EXPORT_MACRO_NAME <no_export_macro_name>]
+#              [INCLUDE_GUARD_NAME <include_guard_name>]
 #              [STATIC_DEFINE <static_define>]
 #              [NO_DEPRECATED_MACRO_NAME <no_deprecated_macro_name>]
 #              [DEFINE_NO_DEPRECATED]
 #              [PREFIX_NAME <prefix_name>]
+#              [CUSTOM_CONTENT_FROM_VARIABLE <variable>]
 #    )
 #
 #
@@ -71,9 +65,10 @@
 #
 # The CMake fragment will generate a file in the
 # ``${CMAKE_CURRENT_BINARY_DIR}`` called ``somelib_export.h`` containing the
-# macros ``SOMELIB_EXPORT``, ``SOMELIB_TEMPLATE_EXPORT``, ``SOMELIB_NO_EXPORT``,
-# ``SOMELIB_DEPRECATED``, ``SOMELIB_DEPRECATED_EXPORT`` and
-# ``SOMELIB_DEPRECATED_NO_EXPORT``.
+# macros ``SOMELIB_EXPORT``, ``SOMELIB_NO_EXPORT``, ``SOMELIB_DEPRECATED``,
+# ``SOMELIB_DEPRECATED_EXPORT`` and ``SOMELIB_DEPRECATED_NO_EXPORT``.
+# They will be followed by content taken from the variable specified by
+# the ``CUSTOM_CONTENT_FROM_VARIABLE`` option, if any.
 # The resulting file should be installed with other headers in the library.
 #
 # The ``BASE_NAME`` argument can be used to override the file name and the
@@ -91,7 +86,7 @@
 # ``OTHER_NAME_EXPORT``, ``OTHER_NAME_NO_EXPORT`` and ``OTHER_NAME_DEPRECATED``
 # etc.
 #
-# The ``BASE_NAME`` may be overridden by specifiying other options in the
+# The ``BASE_NAME`` may be overridden by specifying other options in the
 # function.  For example:
 #
 # .. code-block:: cmake
@@ -191,19 +186,6 @@
 # :prop_tgt:`CXX_VISIBILITY_PRESET <<LANG>_VISIBILITY_PRESET>` and
 # :prop_tgt:`VISIBILITY_INLINES_HIDDEN` instead.
 
-#=============================================================================
-# Copyright 2011 Stephen Kelly <steveire@gmail.com>
-#
-# Distributed under the OSI-approved BSD License (the "License");
-# see accompanying file Copyright.txt for details.
-#
-# This software is distributed WITHOUT ANY WARRANTY; without even the
-# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-# See the License for more information.
-#=============================================================================
-# (To distribute this file outside of CMake, substitute the full
-#  License text for the above reference.)
-
 include(CMakeParseArguments)
 include(CheckCXXCompilerFlag)
 
@@ -218,7 +200,7 @@ macro(_vxl_test_compiler_hidden_visibility)
 
   if(CMAKE_COMPILER_IS_GNUCXX AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS "4.2")
     set(GCC_TOO_OLD TRUE)
-  elseif(CMAKE_COMPILER_IS_GNUC AND CMAKE_C_COMPILER_VERSION VERSION_LESS "4.2")
+  elseif(CMAKE_COMPILER_IS_GNUCC AND CMAKE_C_COMPILER_VERSION VERSION_LESS "4.2")
     set(GCC_TOO_OLD TRUE)
   elseif(CMAKE_CXX_COMPILER_ID MATCHES Intel AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS "12.0")
     set(_INTEL_TOO_OLD TRUE)
@@ -236,14 +218,15 @@ macro(_vxl_test_compiler_hidden_visibility)
     check_cxx_compiler_flag(-fvisibility=hidden COMPILER_HAS_HIDDEN_VISIBILITY)
     check_cxx_compiler_flag(-fvisibility-inlines-hidden
       COMPILER_HAS_HIDDEN_INLINE_VISIBILITY)
-    option(USE_COMPILER_HIDDEN_VISIBILITY
-      "Use HIDDEN visibility support if available." ON)
-    mark_as_advanced(USE_COMPILER_HIDDEN_VISIBILITY)
   endif()
 endmacro()
 
 macro(_vxl_test_compiler_has_deprecated)
+  # NOTE:  Some Embarcadero compilers silently compile __declspec(deprecated)
+  # without error, but this is not a documented feature and the attribute does
+  # not actually generate any warnings.
   if(CMAKE_CXX_COMPILER_ID MATCHES Borland
+      OR CMAKE_CXX_COMPILER_ID MATCHES Embarcadero
       OR CMAKE_CXX_COMPILER_ID MATCHES HP
       OR GCC_TOO_OLD
       OR CMAKE_CXX_COMPILER_ID MATCHES PGI
@@ -270,8 +253,6 @@ macro(_VXL_DO_SET_MACRO_VALUES TARGET_LIBRARY)
   set(DEFINE_DEPRECATED)
   set(DEFINE_EXPORT)
   set(DEFINE_IMPORT)
-  set(DEFINE_TEMPLATE_EXPORT)
-  set(DEFINE_TEMPLATE_IMPORT)
   set(DEFINE_NO_EXPORT)
 
   if (COMPILER_HAS_DEPRECATED_ATTR)
@@ -288,12 +269,12 @@ macro(_VXL_DO_SET_MACRO_VALUES TARGET_LIBRARY)
       set(DEFINE_IMPORT "__declspec(dllimport)")
       set(DEFINE_TEMPLATE_EXPORT)
       set(DEFINE_TEMPLATE_IMPORT)
-    elseif(COMPILER_HAS_HIDDEN_VISIBILITY AND USE_COMPILER_HIDDEN_VISIBILITY)
+    elseif(COMPILER_HAS_HIDDEN_VISIBILITY)
       set(DEFINE_EXPORT "__attribute__((visibility(\"default\")))")
       set(DEFINE_IMPORT "__attribute__((visibility(\"default\")))")
+      set(DEFINE_NO_EXPORT "__attribute__((visibility(\"hidden\")))")
       set(DEFINE_TEMPLATE_EXPORT "${DEFINE_EXPORT}")
       set(DEFINE_TEMPLATE_IMPORT "${DEFINE_IMPORT}")
-      set(DEFINE_NO_EXPORT "__attribute__((visibility(\"hidden\")))")
     endif()
   endif()
 endmacro()
@@ -301,10 +282,10 @@ endmacro()
 macro(_VXL_DO_GENERATE_EXPORT_HEADER TARGET_LIBRARY)
   # Option overrides
   set(options DEFINE_NO_DEPRECATED)
-  set(oneValueArgs PREFIX_NAME BASE_NAME EXPORT_MACRO_NAME
-    TEMPLATE_EXPORT_MACRO_NAME EXPORT_FILE_NAME
+  set(oneValueArgs PREFIX_NAME BASE_NAME EXPORT_MACRO_NAME EXPORT_FILE_NAME
+    TEMPLATE_EXPORT_MACRO_NAME
     DEPRECATED_MACRO_NAME NO_EXPORT_MACRO_NAME STATIC_DEFINE
-    NO_DEPRECATED_MACRO_NAME)
+    NO_DEPRECATED_MACRO_NAME CUSTOM_CONTENT_FROM_VARIABLE INCLUDE_GUARD_NAME)
   set(multiValueArgs)
 
   cmake_parse_arguments(_GEH "${options}" "${oneValueArgs}" "${multiValueArgs}"
@@ -339,9 +320,7 @@ macro(_VXL_DO_GENERATE_EXPORT_HEADER TARGET_LIBRARY)
   if(_GEH_TEMPLATE_EXPORT_MACRO_NAME)
     set(TEMPLATE_EXPORT_MACRO_NAME ${_GEH_PREFIX_NAME}${_GEH_TEMPLATE_EXPORT_MACRO_NAME})
   endif()
-  if(NOT CMAKE_VERSION VERSION_LESS 2.8.12)
-    string(MAKE_C_IDENTIFIER ${EXPORT_MACRO_NAME} EXPORT_MACRO_NAME)
-  endif()
+  string(MAKE_C_IDENTIFIER ${EXPORT_MACRO_NAME} EXPORT_MACRO_NAME)
   if(_GEH_EXPORT_FILE_NAME)
     if(IS_ABSOLUTE ${_GEH_EXPORT_FILE_NAME})
       set(EXPORT_FILE_NAME ${_GEH_EXPORT_FILE_NAME})
@@ -352,43 +331,47 @@ macro(_VXL_DO_GENERATE_EXPORT_HEADER TARGET_LIBRARY)
   if(_GEH_DEPRECATED_MACRO_NAME)
     set(DEPRECATED_MACRO_NAME ${_GEH_PREFIX_NAME}${_GEH_DEPRECATED_MACRO_NAME})
   endif()
-  if(NOT CMAKE_VERSION VERSION_LESS 2.8.12)
-    string(MAKE_C_IDENTIFIER ${DEPRECATED_MACRO_NAME} DEPRECATED_MACRO_NAME)
-  endif()
+  string(MAKE_C_IDENTIFIER ${DEPRECATED_MACRO_NAME} DEPRECATED_MACRO_NAME)
   if(_GEH_NO_EXPORT_MACRO_NAME)
     set(NO_EXPORT_MACRO_NAME ${_GEH_PREFIX_NAME}${_GEH_NO_EXPORT_MACRO_NAME})
   endif()
-  if(NOT CMAKE_VERSION VERSION_LESS 2.8.12)
-    string(MAKE_C_IDENTIFIER ${NO_EXPORT_MACRO_NAME} NO_EXPORT_MACRO_NAME)
-  endif()
+  string(MAKE_C_IDENTIFIER ${NO_EXPORT_MACRO_NAME} NO_EXPORT_MACRO_NAME)
   if(_GEH_STATIC_DEFINE)
     set(STATIC_DEFINE ${_GEH_PREFIX_NAME}${_GEH_STATIC_DEFINE})
   endif()
-  if(NOT CMAKE_VERSION VERSION_LESS 2.8.12)
-    string(MAKE_C_IDENTIFIER ${STATIC_DEFINE} STATIC_DEFINE)
-  endif()
+  string(MAKE_C_IDENTIFIER ${STATIC_DEFINE} STATIC_DEFINE)
 
   if(_GEH_DEFINE_NO_DEPRECATED)
-    set(DEFINE_NO_DEPRECATED TRUE)
+    set(DEFINE_NO_DEPRECATED 1)
+  else()
+    set(DEFINE_NO_DEPRECATED 0)
   endif()
 
   if(_GEH_NO_DEPRECATED_MACRO_NAME)
     set(NO_DEPRECATED_MACRO_NAME
       ${_GEH_PREFIX_NAME}${_GEH_NO_DEPRECATED_MACRO_NAME})
   endif()
-  if(NOT CMAKE_VERSION VERSION_LESS 2.8.12)
-    string(MAKE_C_IDENTIFIER ${NO_DEPRECATED_MACRO_NAME} NO_DEPRECATED_MACRO_NAME)
-  endif()
+  string(MAKE_C_IDENTIFIER ${NO_DEPRECATED_MACRO_NAME} NO_DEPRECATED_MACRO_NAME)
 
-  set(INCLUDE_GUARD_NAME "${EXPORT_MACRO_NAME}_H")
+  if(_GEH_INCLUDE_GUARD_NAME)
+    set(INCLUDE_GUARD_NAME ${_GEH_INCLUDE_GUARD_NAME})
+  else()
+    set(INCLUDE_GUARD_NAME "${EXPORT_MACRO_NAME}_H")
+  endif()
 
   get_target_property(EXPORT_IMPORT_CONDITION ${TARGET_LIBRARY} DEFINE_SYMBOL)
 
   if(NOT EXPORT_IMPORT_CONDITION)
     set(EXPORT_IMPORT_CONDITION ${TARGET_LIBRARY}_EXPORTS)
   endif()
-  if(NOT CMAKE_VERSION VERSION_LESS 2.8.12)
-    string(MAKE_C_IDENTIFIER ${EXPORT_IMPORT_CONDITION} EXPORT_IMPORT_CONDITION)
+  string(MAKE_C_IDENTIFIER ${EXPORT_IMPORT_CONDITION} EXPORT_IMPORT_CONDITION)
+
+  if(_GEH_CUSTOM_CONTENT_FROM_VARIABLE)
+    if(DEFINED "${_GEH_CUSTOM_CONTENT_FROM_VARIABLE}")
+      set(CUSTOM_CONTENT "${${_GEH_CUSTOM_CONTENT_FROM_VARIABLE}}")
+    else()
+      set(CUSTOM_CONTENT "")
+    endif()
   endif()
 
   configure_file("${_VXL_GENERATE_EXPORT_HEADER_MODULE_DIR}/vxlexportheader.cmake.in"
@@ -418,6 +401,9 @@ function(vxl_add_compiler_export_flags)
   _vxl_test_compiler_hidden_visibility()
   _vxl_test_compiler_has_deprecated()
 
+  option(USE_COMPILER_HIDDEN_VISIBILITY
+    "Use HIDDEN visibility support if available." ON)
+  mark_as_advanced(USE_COMPILER_HIDDEN_VISIBILITY)
   if(NOT (USE_COMPILER_HIDDEN_VISIBILITY AND COMPILER_HAS_HIDDEN_VISIBILITY))
     # Just return if there are no flags to add.
     return()
@@ -434,6 +420,7 @@ function(vxl_add_compiler_export_flags)
   if(ARGC GREATER 0)
     set(${ARGV0} "${EXTRA_FLAGS}" PARENT_SCOPE)
   else()
-    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${EXTRA_FLAGS}" PARENT_SCOPE)
+    string(APPEND CMAKE_CXX_FLAGS " ${EXTRA_FLAGS}")
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS}" PARENT_SCOPE)
   endif()
 endfunction()
diff --git a/Modules/ThirdParty/VNL/src/vxl/config/cmake/config/VXLIntrospectionConfig.cmake b/Modules/ThirdParty/VNL/src/vxl/config/cmake/config/VXLIntrospectionConfig.cmake
index a921edcf51..1d1ebc6e72 100644
--- a/Modules/ThirdParty/VNL/src/vxl/config/cmake/config/VXLIntrospectionConfig.cmake
+++ b/Modules/ThirdParty/VNL/src/vxl/config/cmake/config/VXLIntrospectionConfig.cmake
@@ -752,11 +752,10 @@ if(NOT VCL_CXX_HAS_HEADER_LIMITS)
   message(FATAL_ERROR "Compiler is required to have limits.h")
 else()
   PERFORM_CMAKE_TEST_RUN(${VXL_PLFM_TEST_FILE} VCL_NUMERIC_LIMITS_HAS_INFINITY)
-  # ITK does not require has_infinity
-  #if(NOT VCL_NUMERIC_LIMITS_HAS_INFINITY)
-  #message(FATAL_ERROR "Compiler is required to have has_infinity.")
-  #endif()
-  #unset(VCL_NUMERIC_LIMITS_HAS_INFINITY)
+  if(NOT VCL_NUMERIC_LIMITS_HAS_INFINITY)
+  message(FATAL_ERROR "Compiler is required to have has_infinity.")
+  endif()
+  unset(VCL_NUMERIC_LIMITS_HAS_INFINITY)
 endif()
 unset(VCL_CXX_HAS_HEADER_LIMITS)
 
diff --git a/Modules/ThirdParty/VNL/src/vxl/config/cmake/config/vxl_shared_link_test/CMakeLists.txt b/Modules/ThirdParty/VNL/src/vxl/config/cmake/config/vxl_shared_link_test/CMakeLists.txt
index 7b6e95b121..f2133fdffd 100644
--- a/Modules/ThirdParty/VNL/src/vxl/config/cmake/config/vxl_shared_link_test/CMakeLists.txt
+++ b/Modules/ThirdParty/VNL/src/vxl/config/cmake/config/vxl_shared_link_test/CMakeLists.txt
@@ -1,12 +1,32 @@
 # vxl/config/cmake/config/vxl_shared_link_test/CMakeLists.txt
 #
-cmake_minimum_required(VERSION 2.8.9 FATAL_ERROR)
-if(POLICY CMP0025)
-  cmake_policy(SET CMP0025 NEW)
-endif()
-if(POLICY CMP0042)
-  cmake_policy(SET CMP0042 NEW)
-endif()
+cmake_minimum_required(VERSION 3.3.0 FATAL_ERROR)
+# Set policies consistent with newer versions of cmake
+# to ease integration with projects that require newer
+# cmake versions.
+
+foreach(p
+    ## Only policies introduced after the cmake_minimum_required
+    ## version need to explicitly be set to NEW.
+
+    ##----- Policies Introduced by CMake 3.10Â¶
+    CMP0071  #: Let AUTOMOC and AUTOUIC process GENERATED files.
+    CMP0070  #: Define file(GENERATE) behavior for relative paths.
+    ##----- Policies Introduced by CMake 3.9
+    CMP0069  #: INTERPROCEDURAL_OPTIMIZATION is enforced when enabled.
+    CMP0068  #: RPATH settings on macOS do not affect install_name.
+    ##----- Policies Introduced by CMake 3.8
+    CMP0067  #: Honor language standard in try_compile() source-file signature.
+    ##----- Policies Introduced by CMake 3.7
+    CMP0066  #: Honor per-config flags in try_compile() source-file signature.
+    ##----- Policies Introduced by CMake 3.4
+    CMP0065  #: Do not add flags to export symbols from executables without the ENABLE_EXPORTS target property.
+    CMP0064  #: Support new TEST if() operator.
+    )
+  if(POLICY ${p})
+    cmake_policy(SET ${p} NEW)
+  endif()
+endforeach()
 project(vxl_pic_compatible)
 
 add_library(cmTryCompileStaticLib STATIC static_src.cxx)
diff --git a/Modules/ThirdParty/VNL/src/vxl/config/cmake/config/vxl_utils.cmake b/Modules/ThirdParty/VNL/src/vxl/config/cmake/config/vxl_utils.cmake
index 3ae1f1c166..6222df72fe 100644
--- a/Modules/ThirdParty/VNL/src/vxl/config/cmake/config/vxl_utils.cmake
+++ b/Modules/ThirdParty/VNL/src/vxl/config/cmake/config/vxl_utils.cmake
@@ -112,27 +112,21 @@ macro( vxl_add_library )
     if("${VXL_INSTALL_INCLUDE_DIR}" STREQUAL "include/vxl")
       ## Identify the relative path for installing the header files and txx files
       string(REPLACE ${VXL_ROOT_SOURCE_DIR} "${VXL_INSTALL_INCLUDE_DIR}" relative_install_path ${CMAKE_CURRENT_SOURCE_DIR})
-      ## Added in 2.8.11 http://stackoverflow.com/questions/19460707/how-to-set-include-directories-from-a-cmakelists-txt-file
-      if(${CMAKE_VERSION} VERSION_GREATER 2.8.11.2)
-        target_include_directories(${lib_name}
-          PUBLIC
-            $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
-            $<INSTALL_INTERFACE:${relative_install_path}>
-        )
-      endif()
+      target_include_directories(${lib_name}
+        PUBLIC
+          $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
+          $<INSTALL_INTERFACE:${relative_install_path}>
+      )
     else()
       set(relative_install_path "${VXL_INSTALL_INCLUDE_DIR}")
       if(DEFINED header_install_dir)
         set(relative_install_path "${relative_install_path}/${header_install_dir}")
       endif()
-      ## Added in 2.8.11 http://stackoverflow.com/questions/19460707/how-to-set-include-directories-from-a-cmakelists-txt-file
-      if(${CMAKE_VERSION} VERSION_GREATER 2.8.11.2)
-        target_include_directories(${lib_name}
-          PUBLIC
-            $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
-            $<INSTALL_INTERFACE:${VXL_INSTALL_INCLUDE_DIR}>
-        )
-      endif()
+      target_include_directories(${lib_name}
+        PUBLIC
+          $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>
+          $<INSTALL_INTERFACE:${VXL_INSTALL_INCLUDE_DIR}>
+      )
     endif()
     INSTALL_NOBASE_HEADER_FILES(${relative_install_path} ${lib_srcs})
   endif()
@@ -181,23 +175,14 @@ macro(SET_VXL_LIBRARY_PROPERTIES)
         message(FATAL_ERROR "INSTALL_DIR REQUIRED when using USE_HIDDEN_VISIBILITY")
     endif()
 
-    if (BUILD_SHARED_LIBS OR (APPLE AND NOT BUILD_SHARED_LIBS))
+    if (BUILD_SHARED_LIBS OR (APPLE AND NOT BUILD_SHARED_LIBS) ) #APPLE Respects hidden visibility for static builds
       # export flags are only added when building shared libs, they cause
       # mismatched visibility warnings when building statically.
-      if(CMAKE_VERSION VERSION_LESS 2.8.12)
-        # future DEPRECATION notice from cmake:
-        #      "The add_compiler_export_flags function is obsolete.
-        #       Use the CXX_VISIBILITY_PRESET and VISIBILITY_INLINES_HIDDEN
-        #       target properties instead."
-        add_compiler_export_flags(my_abi_flags)
-        set_property(TARGET ${LSLHVP_TARGET_NAME} APPEND PROPERTY COMPILE_FLAGS "${my_abi_flags}")
-      else()
-        if (USE_COMPILER_HIDDEN_VISIBILITY)
-          # Prefer to use target properties supported by newer cmake
-          set_target_properties(${LSLHVP_TARGET_NAME} PROPERTIES CXX_VISIBILITY_PRESET hidden)
-          set_target_properties(${LSLHVP_TARGET_NAME} PROPERTIES C_VISIBILITY_PRESET hidden)
-          set_target_properties(${LSLHVP_TARGET_NAME} PROPERTIES VISIBILITY_INLINES_HIDDEN 1)
-          endif()
+      if (USE_COMPILER_HIDDEN_VISIBILITY)
+        # Prefer to use target properties supported by newer cmake
+        set_target_properties(${LSLHVP_TARGET_NAME} PROPERTIES CXX_VISIBILITY_PRESET hidden)
+        set_target_properties(${LSLHVP_TARGET_NAME} PROPERTIES C_VISIBILITY_PRESET hidden)
+        set_target_properties(${LSLHVP_TARGET_NAME} PROPERTIES VISIBILITY_INLINES_HIDDEN 1)
       endif()
     endif()
   endif()
diff --git a/Modules/ThirdParty/VNL/src/vxl/config/cmake/export/VXLCreateProject.cmake b/Modules/ThirdParty/VNL/src/vxl/config/cmake/export/VXLCreateProject.cmake
index b2e8c964a9..e0142c79ca 100644
--- a/Modules/ThirdParty/VNL/src/vxl/config/cmake/export/VXLCreateProject.cmake
+++ b/Modules/ThirdParty/VNL/src/vxl/config/cmake/export/VXLCreateProject.cmake
@@ -22,11 +22,7 @@ set(VXL_CMAKE_DOXYGEN_DIR  ${VXL_ROOT_SOURCE_DIR}/config/cmake/doxygen)
 get_property(VXLTargets_MODULES GLOBAL PROPERTY VXLTargets_MODULES)
 
 set(VXL_CONFIG_CMAKE_DIR "share/vxl/cmake")
-if(${CMAKE_VERSION} VERSION_LESS 2.8.12)
-   set(INTERFACE_LINK_OPTION "")
-else()
-   set(INTERFACE_LINK_OPTION "EXPORT_LINK_INTERFACE_LIBRARIES")
-endif()
+set(INTERFACE_LINK_OPTION "EXPORT_LINK_INTERFACE_LIBRARIES")
 
 if(VXLTargets_MODULES)
   export(TARGETS
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/CMakeLists.txt b/Modules/ThirdParty/VNL/src/vxl/core/CMakeLists.txt
index 78a984911b..b6af7c2591 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/CMakeLists.txt
+++ b/Modules/ThirdParty/VNL/src/vxl/core/CMakeLists.txt
@@ -9,12 +9,6 @@ doxygen_add_package(core-L2 "Level-2 Vision Libraries")
 doxygen_add_package(core-L2E "Level-2 Vision Libraries (Experimental)")
 doxygen_add_package(core-test "Test Framework")
 
-#
-# Do platform-specific configuration.
-# configure files
-#
-vxl_configure_file(${CMAKE_CURRENT_LIST_DIR}/vxl_config.h.in ${PROJECT_BINARY_DIR}/vxl_config.h ${VXL_INSTALL_INCLUDE_DIR})
-include_directories(${PROJECT_BINARY_DIR})
 
 set(global_sources
  vxl_copyright.h
@@ -28,6 +22,13 @@ else()
 endif()
 INSTALL_NOBASE_HEADER_FILES(${prefix} ${global_sources})
 
+#
+# Do platform-specific configuration.
+# configure files
+#
+vxl_configure_file(${CMAKE_CURRENT_LIST_DIR}/vxl_config.h.in ${PROJECT_BINARY_DIR}/vxl_config.h ${prefix})
+include_directories(${PROJECT_BINARY_DIR})
+
 if(BUILD_CORE_UTILITIES)
   # POSIX layer
   add_subdirectory(vpl)
@@ -122,7 +123,7 @@ endif()
 
 
 # video
-CMAKE_DEPENDENT_OPTION (BUILD_CORE_VIDEO "Build VXL's core video libraries" ON
+CMAKE_DEPENDENT_OPTION (BUILD_CORE_VIDEO "Build VXL's core video libraries" OFF
                         "BUILD_CORE_UTILITIES;BUILD_CORE_IMAGING" OFF)
 if (BUILD_CORE_VIDEO)
   add_subdirectory(vidl)
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/CMakeLists.txt b/Modules/ThirdParty/VNL/src/vxl/core/vnl/CMakeLists.txt
index a48b5640bf..59231aa70f 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/CMakeLists.txt
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/CMakeLists.txt
@@ -24,6 +24,10 @@ option(VNL_CONFIG_THREAD_SAFE
   option(VNL_CONFIG_ENABLE_SSE2
     "Enable Streaming SIMD Extensions 2 optimisations (hardware dependant). Currently broken. For use by VNL developers only." OFF)
 #endif()
+if(VNL_CONFIG_ENABLE_SSE2)
+  # Tested on ubuntu and Mac.  ctest becomes unstable and failures change between runs.
+  message(FATAL_ERROR  "VNL_CONFIG_ENABLE_SSE2 option currently fails testing on all platforms,  this is not suitable for use at the momemnt.")
+endif()
 
 option(VNL_CONFIG_ENABLE_SSE2_ROUNDING
   "Enable Streaming SIMD Extensions 2 implementation of rounding (hardware dependant)."
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/tests/test_convolve.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/tests/test_convolve.cxx
index 71e6e80d0a..1f14291ed6 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/tests/test_convolve.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/tests/test_convolve.cxx
@@ -63,7 +63,6 @@ void test_convolve()
 
   TEST_NEAR("vnl_convolve() with_fft(16384)", (r9-r10).two_norm(), 0.0, 1e-6);
   std::cout << "Done FFT-2-based 10000x2000 convolution in " << ms2/double(ntimes) << " milliseconds\n";
-  TEST("vnl_convolve() timing: should be at least 2.5x faster", 5*ms2 < 2*ms1, true);
 
   vnl_vector<double> r11;
   const std::clock_t timer_05 = std::clock();
@@ -73,7 +72,6 @@ void test_convolve()
   const int ms3 = ( timer_06 - timer_05)/ (CLOCKS_PER_SEC/1000);
   TEST_NEAR("vnl_convolve() with_fft(12800)", (r9-r11).two_norm(), 0.0, 1e-6);
   std::cout << "Done FFT-2,5-based 10000x2000 convolution in " << ms3/double(ntimes) << " milliseconds\n";
-  TEST("vnl_convolve() timing: should even be faster", 2*ms3 < 3*ms2, true);
 
   vnl_vector<double> r12;
   const std::clock_t timer_07 = std::clock();
@@ -83,7 +81,6 @@ void test_convolve()
   const int ms4 = ( timer_08 - timer_07)/ (CLOCKS_PER_SEC/1000);
   TEST_NEAR("vnl_convolve() with_fft(27648)", (r9-r12).two_norm(), 0.0, 1e-6);
   std::cout << "Done FFT-2,3-based 10000x2000 convolution in " << ms4/double(ntimes) << " milliseconds\n";
-  TEST("vnl_convolve() timing: should be slower", 5*ms4 > 3*ms2, true);
 
   double c1_data[] = { -1, 0, 1, 2, 3, 4 };
   vnl_vector<double> c1(6, 6, c1_data);
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_brent.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_brent.cxx
index 89eb069622..c1c99263ae 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_brent.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_brent.cxx
@@ -23,7 +23,7 @@ double vnl_brent::minimize_given_bounds(double ax, double bx, double cx,
                                         double tol,
                                         double *xmin)
 {
-  assert( xmin != NULL );
+  assert( xmin != VXL_NULLPTR );
   this->set_x_tolerance( tol );
   *xmin = vnl_brent_minimizer::minimize_given_bounds( ax, bx, cx );
   return vnl_brent_minimizer::f_at_last_minimum();
@@ -33,7 +33,7 @@ double vnl_brent::minimize_given_bounds_and_1st_f(double ax, double bx,
                                                   double fb, double cx,
                                                   double tol, double *xmin)
 {
-  assert( xmin != NULL );
+  assert( xmin != VXL_NULLPTR );
   this->set_x_tolerance( tol );
   *xmin = vnl_brent_minimizer::minimize_given_bounds_and_one_f( ax, bx, cx, fb );
   return vnl_brent_minimizer::f_at_last_minimum();
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_complex_generalized_schur.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_complex_generalized_schur.cxx
index 24f9607238..214d4957a5 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_complex_generalized_schur.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_complex_generalized_schur.cxx
@@ -30,10 +30,10 @@ bool vnl_generalized_schur(vnl_matrix<std::complex<double> > *A,
   assert(B->rows() == B->cols());
 
   long n = A->rows();
-  assert(alpha!=0); alpha->set_size(n);    alpha->fill(0);
-  assert(beta!=0);  beta ->set_size(n);    beta ->fill(0);
-  assert(L!=0);     L    ->set_size(n, n); L    ->fill(0);
-  assert(R!=0);     R    ->set_size(n, n); R    ->fill(0);
+  assert(alpha!=VXL_NULLPTR); alpha->set_size(n);    alpha->fill(0);
+  assert(beta!=VXL_NULLPTR);  beta ->set_size(n);    beta ->fill(0);
+  assert(L!=VXL_NULLPTR);     L    ->set_size(n, n); L    ->fill(0);
+  assert(R!=VXL_NULLPTR);     R    ->set_size(n, n); R    ->fill(0);
 
   long sdim = 0;
   long lwork = 1000 + (8*n + 16);
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_convolve.hxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_convolve.hxx
index 3c5f3f0895..a92377cf5c 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_convolve.hxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_convolve.hxx
@@ -47,7 +47,7 @@ vnl_vector<U> vnl_convolve_cyclic(vnl_vector<T1> const& v1, vnl_vector<T2> const
   if (n == 1) return vnl_vector<U>(1, U(v1[0]*v2[0]));
 
   if (use_fft)
-    return vnl_convolve_cyclic_using_fft(v1, v2, (U*)0);
+    return vnl_convolve_cyclic_using_fft(v1, v2, (U*)VXL_NULLPTR);
 
   vnl_vector<U> ret(n, (U)0); // all elements already initialized to zero
   for (unsigned int k=0; k<n; ++k)
@@ -83,7 +83,7 @@ vnl_vector<U> vnl_convolve_using_fft(vnl_vector<T1> const& v1, vnl_vector<T2> co
   vnl_vector<U> w1(n, U(0)); for (unsigned i=0; i<v1.size(); ++i) w1[i]=U(v1[i]);
   vnl_vector<U> w2(n, U(0)); for (unsigned i=0; i<v2.size(); ++i) w2[i]=U(v2[i]);
   // convolve, using n-points FFT:
-  w1 = vnl_convolve_cyclic_using_fft(w1, w2, (U*)0);
+  w1 = vnl_convolve_cyclic_using_fft(w1, w2, (U*)VXL_NULLPTR);
   // return w1, but possibly drop the last few (zero) entries:
   return vnl_vector<U>(v1.size()+v2.size()-1, v1.size()+v2.size()-1, w1.data_block());
 }
@@ -98,7 +98,7 @@ vnl_vector<T> vnl_convolve(vnl_vector<T> const& v1, vnl_vector<T> const& v2, int
   if (v2.size() == 1) return v1*v2[0];
 
   if (use_fft != 0)
-    return vnl_convolve_using_fft(v1, v2, (T*)0, use_fft);
+    return vnl_convolve_using_fft(v1, v2, (T*)VXL_NULLPTR, use_fft);
 
   unsigned int n = v1.size() + v2.size() - 1;
   vnl_vector<T> ret(n, (T)0); // all elements already initialized to zero
@@ -120,7 +120,7 @@ vnl_vector<U> vnl_convolve(vnl_vector<T1> const& v1, vnl_vector<T2> const& v2, U
     return vnl_vector<U>(0);
 
   if (use_fft != 0)
-    return vnl_convolve_using_fft(v1, v2, (U*)0, use_fft);
+    return vnl_convolve_using_fft(v1, v2, (U*)VXL_NULLPTR, use_fft);
 
   unsigned int n = v1.size() + v2.size() - 1;
   vnl_vector<U> ret(n, (U)0); // all elements already initialized to zero
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_fft_prime_factors.hxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_fft_prime_factors.hxx
index 32f784ba87..a11870bf6f 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_fft_prime_factors.hxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_fft_prime_factors.hxx
@@ -9,7 +9,7 @@
 
 template <class T>
 vnl_fft_prime_factors<T>::vnl_fft_prime_factors()
-  : trigs_(0)
+  : trigs_(VXL_NULLPTR)
   , number_(0)
 {
 }
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_generalized_schur.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_generalized_schur.cxx
index 497da54958..d7d7b1960c 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_generalized_schur.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_generalized_schur.cxx
@@ -30,11 +30,11 @@ bool vnl_generalized_schur(vnl_matrix<double> *A,
   assert(A->cols() == B->cols());
 
   long n = A->rows();
-  assert(alphar!=0); alphar->set_size(n);    alphar->fill(0);
-  assert(alphai!=0); alphai->set_size(n);    alphai->fill(0);
-  assert(beta!=0);   beta  ->set_size(n);    beta  ->fill(0);
-  assert(L!=0);      L     ->set_size(n, n); L     ->fill(0);
-  assert(R!=0);      R     ->set_size(n, n); R     ->fill(0);
+  assert(alphar!=VXL_NULLPTR); alphar->set_size(n);    alphar->fill(0);
+  assert(alphai!=VXL_NULLPTR); alphai->set_size(n);    alphai->fill(0);
+  assert(beta!=VXL_NULLPTR);   beta  ->set_size(n);    beta  ->fill(0);
+  assert(L!=VXL_NULLPTR);      L     ->set_size(n, n); L     ->fill(0);
+  assert(R!=VXL_NULLPTR);      R     ->set_size(n, n); R     ->fill(0);
 
   long sdim = 0;
   long lwork = 1000 + (8*n + 16);
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_lbfgs.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_lbfgs.cxx
index 9d125ea561..d1d84918bc 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_lbfgs.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_lbfgs.cxx
@@ -77,7 +77,7 @@ bool vnl_lbfgs::minimize(vnl_vector<double>& x)
     std::cerr << "vnl_lbfgs: ";
 
   double best_f = 0;
-  vnl_vector<double> best_x = x;
+  vnl_vector<double> best_x;
 
   bool ok;
   this->num_evaluations_ = 0;
@@ -105,8 +105,8 @@ bool vnl_lbfgs::minimize(vnl_vector<double>& x)
       best_f = f;
     }
 
-#define print_(i,a,b,c,d) std::cerr<<std::setw(6)<<i<<' '<<std::setw(20)<<a<<' '\
-           <<std::setw(20)<<b<<' '<<std::setw(20)<<c<<' '<<std::setw(20)<<d<<'\n'
+#define print_(i,a,b,c,d) std::cerr<<std::setw(6)<<(i)<<' '<<std::setw(20)<<(a)<<' '\
+           <<std::setw(20)<<(b)<<' '<<std::setw(20)<<(c)<<' '<<std::setw(20)<<(d)<<'\n'
 
     if (check_derivatives_)
     {
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_levenberg_marquardt.h b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_levenberg_marquardt.h
index 157efa00eb..057225ded1 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_levenberg_marquardt.h
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_levenberg_marquardt.h
@@ -48,7 +48,7 @@ class VNL_ALGO_EXPORT vnl_levenberg_marquardt : public vnl_nonlinear_minimizer
   //: Initialize with the function object that is to be minimized.
   vnl_levenberg_marquardt(vnl_least_squares_function& f) { init(&f); }
 
-  ~vnl_levenberg_marquardt();
+  ~vnl_levenberg_marquardt() VXL_OVERRIDE;
 
   //: Minimize the function supplied in the constructor until convergence or failure.
   //  On return, x is such that f(x) is the lowest value achieved.
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_lsqr.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_lsqr.cxx
index eae38d40e4..f24bea2984 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_lsqr.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_lsqr.cxx
@@ -24,7 +24,7 @@ public:
 
   lsqrVNL()
     {
-    this->ls_ = NULL;
+    this->ls_ = VXL_NULLPTR;
     }
 
   virtual ~lsqrVNL()
@@ -88,7 +88,7 @@ vnl_lsqr::~vnl_lsqr()
 }
 
 // Requires number_of_residuals() of workspace in rw.
-int vnl_lsqr::aprod_(long* mode, long* m, long* n, double* x, double* y, long* /*leniw*/, long* /*lenrw*/, long* /*iw*/, double* rw, void* userdata)
+int vnl_lsqr::aprod_(const long* mode, const long* m, const long* n, double* x, double* y, long* /*leniw*/, long* /*lenrw*/, long* /*iw*/, double* rw, void* userdata)
 {
   //
   // THIS CODE IS DEPRECATED
@@ -123,7 +123,7 @@ int vnl_lsqr::minimize(vnl_vector<double>& result)
   long n = ls_->get_number_of_unknowns();
   double damp = 0;
   long leniw = 1;
-  long* iw = 0;
+  long* iw = VXL_NULLPTR;
   long lenrw = m;
 #ifdef __GNUC__
   double rw[m];
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_lsqr.h b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_lsqr.h
index 6ab8d07f69..8ca0959993 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_lsqr.h
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_lsqr.h
@@ -74,7 +74,7 @@ class VNL_ALGO_EXPORT vnl_lsqr
   double result_norm_;
   long return_code_;
 
-  static int aprod_(long* mode, long* m, long* n, double* x, double* y,
+  static int aprod_(const long* mode, const long* m, const long* n, double* x, double* y,
                     long* leniw, long* lenrw, long* iw, double* rw,
                     void* userdata);
 };
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_matrix_inverse.h b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_matrix_inverse.h
index 56e54c1fb4..12d93958e0 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_matrix_inverse.h
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_matrix_inverse.h
@@ -35,7 +35,7 @@ template <class T>
 struct vnl_matrix_inverse : public vnl_svd<T>
 {
   vnl_matrix_inverse(vnl_matrix<T> const & M): vnl_svd<T>(M) { }
-  ~vnl_matrix_inverse() {}
+  ~vnl_matrix_inverse() VXL_OVERRIDE {}
 
   operator vnl_matrix<T> () const { return this->inverse(); }
 };
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_qr.hxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_qr.hxx
index fb19f73d27..e48bbed9f7 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_qr.hxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_qr.hxx
@@ -199,10 +199,10 @@ vnl_vector<T> vnl_qr<T>::solve(const vnl_vector<T>& b) const
   vnl_linpack_qrsl(qrdc_out_.data_block(),
                    &n, &n, &p,
                    qraux_.data_block(),
-                   b_data, (T*)0, Qt_B.data_block(),
+                   b_data, (T*)VXL_NULLPTR, Qt_B.data_block(),
                    x.data_block(),
-                   (T*)0/*residual*/,
-                   (T*)0/*Ax*/,
+                   (T*)VXL_NULLPTR/*residual*/,
+                   (T*)VXL_NULLPTR/*Ax*/,
                    &JOB,
                    &info);
 
@@ -230,11 +230,11 @@ vnl_vector<T> vnl_qr<T>::QtB(const vnl_vector<T>& b) const
                    &n, &n, &p,
                    qraux_.data_block(),
                    b_data,
-                   (T*)0,               // A: Qb
+                   (T*)VXL_NULLPTR,               // A: Qb
                    Qt_B.data_block(),   // B: Q'b
-                   (T*)0,               // C: x
-                   (T*)0,               // D: residual
-                   (T*)0,               // E: Ax
+                   (T*)VXL_NULLPTR,               // C: x
+                   (T*)VXL_NULLPTR,               // D: residual
+                   (T*)VXL_NULLPTR,               // E: Ax
                    &JOB,
                    &info);
 
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_sparse_symmetric_eigensystem.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_sparse_symmetric_eigensystem.cxx
index 025e0f07cc..dd4d49bc91 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_sparse_symmetric_eigensystem.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_sparse_symmetric_eigensystem.cxx
@@ -29,7 +29,7 @@ void sse_op_callback(const long* n,
                      const double* p,
                      double* q)
 {
-  assert(current_system != 0);
+  assert(current_system != VXL_NULLPTR);
 
   current_system->CalculateProduct(*n,*m,p,q);
 }
@@ -46,7 +46,7 @@ void sse_iovect_callback(const long* n,
                          const long* j,
                          const long* k)
 {
-  assert(current_system != 0);
+  assert(current_system != VXL_NULLPTR);
 
   if (*k==0)
     current_system->SaveVectors(*n,*m,q,*j-*m);
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_svd_economy.hxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_svd_economy.hxx
index bb20b6b7e8..a2e7c825b4 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_svd_economy.hxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/algo/vnl_svd_economy.hxx
@@ -45,7 +45,7 @@ vnl_svd_economy<real_t>::vnl_svd_economy( vnl_matrix<real_t> const& M ) :
   vnl_linpack_svdc_economy((real_t*)X, &m_, &m_, &n_,
                            wspace.data_block(),
                            espace.data_block(),
-                           0, &ldu,
+                           VXL_NULLPTR, &ldu,
                            vspace.data_block(), &n_,
                            work.data_block(),
                            &job, &info);
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/basic_operation_timings.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/basic_operation_timings.cxx
index 625b9b51b8..592a05a8af 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/basic_operation_timings.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/basic_operation_timings.cxx
@@ -17,7 +17,7 @@
 const unsigned nstests = 10;
 
 
-void fill_with_rng(double * begin, double * end, double a, double b, vnl_random &rng)
+void fill_with_rng(double * begin, const double * end, double a, double b, vnl_random &rng)
 {
   while (begin != end)
   {
@@ -26,7 +26,7 @@ void fill_with_rng(double * begin, double * end, double a, double b, vnl_random
   }
 }
 
-void fill_with_rng(float * begin, float * end, float a, float b, vnl_random &rng)
+void fill_with_rng(float * begin, const float * end, float a, float b, vnl_random &rng)
 {
   while (begin != end)
   {
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_arithmetic.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_arithmetic.cxx
index b269ba6ba6..db889e64fc 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_arithmetic.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_arithmetic.cxx
@@ -15,10 +15,10 @@
 // --- dynamic ------------------------------
 
 #define NewMat(mat, r,c,data) \
-   assert( sizeof(data) >= r*c*sizeof(double) ); \
+   assert( sizeof(data) >= (r)*(c)*sizeof(double) ); \
    vnl_matrix<double> mat( data, r, c )
 #define NewVec(vec, n,data) \
-   assert( sizeof(data) >= n*sizeof(double) ); \
+   assert( sizeof(data) >= (n)*sizeof(double) ); \
    vnl_vector<double> vec( data, n )
 
 static
@@ -35,10 +35,10 @@ test_arithmetic_dynamic()
 // --- ref ----------------------------------
 
 #define NewMat(mat, r,c,data) \
-   assert( sizeof(data) >= r*c*sizeof(double) ); \
+   assert( sizeof(data) >= (r)*(c)*sizeof(double) ); \
    vnl_matrix_ref<double> mat( r, c, data )
 #define NewVec(vec, n,data) \
-   assert( sizeof(data) >= n*sizeof(double) ); \
+   assert( sizeof(data) >= (n)*sizeof(double) ); \
    vnl_vector_ref<double> vec( n, data )
 
 static
@@ -55,10 +55,10 @@ test_arithmetic_ref()
 #undef NewVec
 
 #define NewMat(mat, r,c,data) \
-   assert( sizeof(data) >= r*c*sizeof(double) ); \
+   assert( sizeof(data) >= (r)*(c)*sizeof(double) ); \
    vnl_matrix_fixed<double,r,c> mat( data )
 #define NewVec(vec, n,data) \
-   assert( sizeof(data) >= n*sizeof(double) ); \
+   assert( sizeof(data) >= (n)*sizeof(double) ); \
    vnl_vector_fixed<double,n> vec( data )
 
 void
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_matlab.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_matlab.cxx
index 4b60e8a01d..a6502a2243 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_matlab.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_matlab.cxx
@@ -32,7 +32,7 @@
 // get a byte-swapped file, short of reading in a native file and swapping it
 // and writing it back out, and that isn't any easier.
 void matlab_write_swapped(std::ostream &f,
-                          float *array,
+                          const float *array,
                           unsigned size,
                           char const *name)
 {
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_matrix.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_matrix.cxx
index 8919c4a4fc..2fdac67c58 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_matrix.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_matrix.cxx
@@ -62,7 +62,7 @@ void test_int()
   try { m0.get(0,25); }  // Raise out of bounds exception.
   catch(...) { exceptionThrownAndCaught = true; }
   TEST("Out of bounds get(0,25)", exceptionThrownAndCaught, true);
-  
+
   exceptionThrownAndCaught = false;
   try { m0.get(25,0); }  // Raise out of bounds exception.
   catch(...) { exceptionThrownAndCaught = true; }
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_na.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_na.cxx
index 7f371724e6..aed9edafb4 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_na.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_na.cxx
@@ -9,9 +9,9 @@
 
 
 #define print_hex(p) \
-  std::hex<<std::setfill('0')<<std::setw(2)<<(short)reinterpret_cast<unsigned char*>(&p)[sizeof(p)-1]; \
+  std::hex<<std::setfill('0')<<std::setw(2)<<(short)reinterpret_cast<unsigned char*>(&(p))[sizeof(p)-1]; \
   for (unsigned int i=2; i<=sizeof(p); ++i) \
-    std::cout<<std::setfill('0')<<std::setw(2)<<(short)(reinterpret_cast<unsigned char*>(&p))[sizeof(p)-i]; \
+    std::cout<<std::setfill('0')<<std::setw(2)<<(short)(reinterpret_cast<unsigned char*>(&(p)))[sizeof(p)-i]; \
   std::cout<<std::dec
 
 
@@ -156,9 +156,9 @@ void test_na()
   float na_f = vnl_na(float());
 
 #define print_hex(p) \
-  std::hex<<std::setfill('0')<<std::setw(2)<<(short)reinterpret_cast<unsigned char*>(&p)[sizeof(p)-1]; \
+  std::hex<<std::setfill('0')<<std::setw(2)<<(short)reinterpret_cast<unsigned char*>(&(p))[sizeof(p)-1]; \
   for (unsigned int i=2; i<=sizeof(p); ++i) \
-    std::cout<<std::setfill('0')<<std::setw(2)<<(short)(reinterpret_cast<unsigned char*>(&p))[sizeof(p)-i]; \
+    std::cout<<std::setfill('0')<<std::setw(2)<<(short)(reinterpret_cast<unsigned char*>(&(p)))[sizeof(p)-i]; \
   std::cout<<std::dec
 
   std::cout << "qnan_d = " << qnan_d << " = " << print_hex(qnan_d) << '\n'
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_rational.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_rational.cxx
index 0a4da8e739..a5d669e143 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_rational.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_rational.cxx
@@ -18,6 +18,28 @@ inline vnl_rational vnl_sqrt(vnl_rational x) { return vnl_rational(std::sqrt(dou
 static void test_operators()
 {
   vnl_rational a(-5L), b(7,-1), c, d(3,7), e(2,0);
+  vnl_rational z_default;
+  TEST("==", z_default==0L, true);
+
+  vnl_rational z_int(static_cast<int>(0));
+  TEST("==", z_int==0L, true);
+  vnl_rational z_uint(static_cast<unsigned int>(0) );
+  TEST("==", z_uint==0L, true);
+
+  vnl_rational z_short(static_cast<int>(0));
+  TEST("==", z_short==0L, true);
+  vnl_rational z_ushort(static_cast<unsigned int>(0) );
+  TEST("==", z_ushort==0L, true);
+
+  vnl_rational z_long(static_cast<long>(0));
+  TEST("==", z_long==0L, true);
+  vnl_rational z_ulong(static_cast<unsigned long>(0));
+  TEST("==", z_ulong==0L, true);
+#if 0
+  vnl_rational z_mixed(static_cast<short>(0), static_cast<unsigned int>(1) );
+  TEST("==", z_mixed==0L, true);
+#endif
+
   TEST("==", a==-5L, true);
   TEST("==", 5L==-a, true);
   TEST("==", b==-7, true);
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_sym_matrix.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_sym_matrix.cxx
index b49115fe54..a77f7b4518 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_sym_matrix.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/tests/test_sym_matrix.cxx
@@ -83,7 +83,7 @@ void test_int()
   try { sm1.get(0,25); }  // Raise out of bounds exception.
   catch(...) { exceptionThrownAndCaught = true; }
   TEST("Out of bounds get(0,25)", exceptionThrownAndCaught, true);
-  
+
   exceptionThrownAndCaught = false;
   try { sm1.get(25,0); }  // Raise out of bounds exception.
   catch(...) { exceptionThrownAndCaught = true; }
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_c_na_vector.hxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_c_na_vector.hxx
index e5ec177ee1..2d6af99d6e 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_c_na_vector.hxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_c_na_vector.hxx
@@ -153,8 +153,8 @@ template VNL_EXPORT void vnl_c_na_vector_inf_norm(T const *, unsigned, S *)
 #undef VNL_C_NA_VECTOR_INSTANTIATE_ordered
 #define VNL_C_NA_VECTOR_INSTANTIATE_ordered(T) \
 VNL_C_NA_VECTOR_INSTANTIATE_norm(T, vnl_c_na_vector<T >::abs_t); \
-template class VNL_EXPORT vnl_c_na_vector<T >; \
-template VNL_EXPORT std::ostream& print_na_vector(std::ostream &,T const *,unsigned)
+template class vnl_c_na_vector<T >; \
+template std::ostream& print_na_vector(std::ostream &,T const *,unsigned)
 
 
 #undef VNL_C_NA_VECTOR_INSTANTIATE_unordered
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_c_vector.hxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_c_vector.hxx
index eb558a937a..37e1221e85 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_c_vector.hxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_c_vector.hxx
@@ -441,7 +441,7 @@ template VNL_EXPORT void vnl_c_vector_inf_norm(T const *, unsigned, S *)
 #undef VNL_C_VECTOR_INSTANTIATE_ordered
 #define VNL_C_VECTOR_INSTANTIATE_ordered(T) \
 VNL_C_VECTOR_INSTANTIATE_norm(T, vnl_c_vector<T >::abs_t); \
-template class VNL_EXPORT vnl_c_vector<T >; \
+template class vnl_c_vector<T >; \
 template VNL_EXPORT std::ostream& print_vector(std::ostream &,T const *,unsigned)
 
 #undef VNL_C_VECTOR_INSTANTIATE_unordered
@@ -450,7 +450,7 @@ VCL_DO_NOT_INSTANTIATE(T vnl_c_vector<T >::max_value(T const *, unsigned), T(0))
 VCL_DO_NOT_INSTANTIATE(T vnl_c_vector<T >::min_value(T const *, unsigned), T(0)); \
 VCL_DO_NOT_INSTANTIATE(unsigned vnl_c_vector<T >::arg_max(T const *, unsigned), 0U); \
 VCL_DO_NOT_INSTANTIATE(unsigned vnl_c_vector<T >::arg_min(T const *, unsigned), 0U); \
-template class VNL_EXPORT vnl_c_vector<T >; \
+template class vnl_c_vector<T >; \
 VNL_C_VECTOR_INSTANTIATE_norm(T, vnl_c_vector<T >::abs_t);
 
 #ifndef DOXYGEN_SHOULD_SKIP_THIS
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_file_matrix.h b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_file_matrix.h
index e831cfb116..7ee40fb0e2 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_file_matrix.h
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_file_matrix.h
@@ -30,7 +30,7 @@ class VNL_TEMPLATE_EXPORT vnl_file_matrix : public vnl_matrix<T>
   vnl_file_matrix(char const* filename);
 
   operator safe_bool () const
-    { return (ok_)? VCL_SAFE_BOOL_TRUE : 0; }
+    { return (ok_)? VCL_SAFE_BOOL_TRUE : VXL_NULLPTR; }
   bool operator!() const
     { return !ok_; }
 
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_file_vector.h b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_file_vector.h
index 99cd366e85..8d5c9a78bf 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_file_vector.h
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_file_vector.h
@@ -31,7 +31,7 @@ class VNL_TEMPLATE_EXPORT vnl_file_vector : public vnl_vector<T>
   vnl_file_vector(char const* filename);
 
   operator safe_bool () const
-    { return (ok_)? VCL_SAFE_BOOL_TRUE : 0; }
+    { return (ok_)? VCL_SAFE_BOOL_TRUE : VXL_NULLPTR; }
   bool operator!() const
     { return !ok_; }
 
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_math.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_math.cxx
index 1f6bd5f718..8d3f9a8cfc 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_math.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_math.cxx
@@ -26,7 +26,7 @@
 #endif
 
 #elif VXL_HAS_STD_ISFINITE || VXL_HAS_STD_ISNAN ||  VXL_HAS_STD_ISNORMAL
-# include<math.h>
+# include<cmath>
 # if VXL_HAS_STD_ISFINITE
 #    define finite  std::isfinite
 #    define finitef std::isfinite
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_math.h b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_math.h
index 4a7e4a7669..c66e3df9ab 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_math.h
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_math.h
@@ -153,41 +153,28 @@ namespace vnl_math
 namespace vnl_math
 {
 #if VXL_FULLCXX11SUPPORT
-  // Prefer to use perfect forwarding to the std library if C++11 features are available.
-  //http://stackoverflow.com/questions/9864125/c11-how-to-alias-a-function
-  template <typename... Args>
-    auto isnan(Args&&... args) -> decltype(std::isnan(std::forward<Args>(args)...)) {
-      return std::isnan(std::forward<Args>(args)...);
+  using std::isnan;
+  // Ensure proper conversion to bool type.
+  // Return a signed integer type has been seen with the following
+  // compilers/libstdc++:
+  //  g++ (GCC) 7.2.1 20170829 (Red Hat 7.2.1-1)
+  //  g++ (GCC) 6.3.1 20170216 (Red Hat 6.3.1-3)
+  template <typename TArg>
+  bool isinf(TArg&& arg)
+    {
+    return bool(std::isinf(std::forward<TArg>(arg)));
     }
-  template <typename... Args>
-    auto isinf(Args&&... args) -> decltype(std::isinf(std::forward<Args>(args)...)) {
-      return std::isinf(std::forward<Args>(args)...);
-    }
-  template <typename... Args>
-    auto isfinite(Args&&... args) -> decltype(std::isfinite(std::forward<Args>(args)...)) {
-      return std::isfinite(std::forward<Args>(args)...);
-    }
-  template <typename... Args>
-    auto isnormal(Args&&... args) -> decltype(std::isnormal(std::forward<Args>(args)...)) {
-      return std::isnormal(std::forward<Args>(args)...);
-    }
-  template <typename... Args>
-    auto max(Args&&... args) -> decltype(std::max(std::forward<Args>(args)...)) {
-      return std::max(std::forward<Args>(args)...);
-    }
-  template <typename... Args>
-    auto min(Args&&... args) -> decltype(std::min(std::forward<Args>(args)...)) {
-      return std::min(std::forward<Args>(args)...);
-    }
-  //cbrt is defined in C++11
-  template <typename... Args>
-    auto cuberoot(Args&&... args) -> decltype(std::cbrt(std::forward<Args>(args)...)) {
-      return std::cbrt(std::forward<Args>(args)...);
-    }
-  template <typename... Args>
-    auto hypot(Args&&... args) -> decltype(std::hypot(std::forward<Args>(args)...)) {
-      return std::hypot(std::forward<Args>(args)...);
+  using std::isfinite;
+  using std::isnormal;
+  using std::max;
+  using std::min;
+  using std::cbrt;
+  template <typename TArg>
+  TArg cuberoot(TArg&& arg)
+    {
+    return std::cbrt(std::forward<TArg>(arg));
     }
+  using std::hypot;
 #else
  // isnan
  inline bool isnan(char)               { return false; }
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_matlab_print.h b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_matlab_print.h
index d818e12015..c001352b08 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_matlab_print.h
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_matlab_print.h
@@ -46,7 +46,7 @@ std::ostream &vnl_matlab_print(std::ostream &,
 template <class T> VNL_TEMPLATE_EXPORT
 std::ostream &vnl_matlab_print(std::ostream &,
                               vnl_diag_matrix<T> const&,
-                              char const *variable_name =0,
+                              char const *variable_name =VXL_NULLPTR,
                               vnl_matlab_print_format =vnl_matlab_print_format_default);
 
 //: print a vnl_matrix<T>.
@@ -54,7 +54,7 @@ std::ostream &vnl_matlab_print(std::ostream &,
 template <class T> VNL_TEMPLATE_EXPORT
 std::ostream &vnl_matlab_print(std::ostream &,
                               vnl_matrix<T> const&,
-                              char const *variable_name =0,
+                              char const *variable_name =VXL_NULLPTR,
                               vnl_matlab_print_format =vnl_matlab_print_format_default);
 
 //: print a vnl_matrix_fixed<T>.
@@ -62,7 +62,7 @@ std::ostream &vnl_matlab_print(std::ostream &,
 template <class T, unsigned int n, unsigned int m> VNL_TEMPLATE_EXPORT
 std::ostream &vnl_matlab_print(std::ostream &,
                               vnl_matrix_fixed<T,n,m> const&,
-                              char const *variable_name =0,
+                              char const *variable_name =VXL_NULLPTR,
                               vnl_matlab_print_format =vnl_matlab_print_format_default);
 
 //: print a vnl_matrix_ref<T>.
@@ -70,7 +70,7 @@ std::ostream &vnl_matlab_print(std::ostream &,
 template <class T> VNL_TEMPLATE_EXPORT
 std::ostream &vnl_matlab_print(std::ostream &,
                               vnl_matrix_ref<T> const &,
-                              char const *variable_name =0,
+                              char const *variable_name =VXL_NULLPTR,
                               vnl_matlab_print_format =vnl_matlab_print_format_default);
 
 //: print a vnl_vector<T>.
@@ -78,7 +78,7 @@ std::ostream &vnl_matlab_print(std::ostream &,
 template <class T> VNL_TEMPLATE_EXPORT
 std::ostream &vnl_matlab_print(std::ostream &,
                               vnl_vector<T> const &,
-                              char const *variable_name =0,
+                              char const *variable_name =VXL_NULLPTR,
                               vnl_matlab_print_format =vnl_matlab_print_format_default);
 
 //: print a vnl_vector_fixed<T>.
@@ -86,7 +86,7 @@ std::ostream &vnl_matlab_print(std::ostream &,
 template <class T, unsigned int n> VNL_TEMPLATE_EXPORT
 std::ostream &vnl_matlab_print(std::ostream &,
                               vnl_vector_fixed<T,n> const &,
-                              char const *variable_name =0,
+                              char const *variable_name =VXL_NULLPTR,
                               vnl_matlab_print_format =vnl_matlab_print_format_default);
 
 
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_matlab_print2.h b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_matlab_print2.h
index bdac336023..061e7b0e11 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_matlab_print2.h
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_matlab_print2.h
@@ -61,7 +61,7 @@ template <class T>
 inline
 vnl_matlab_print_proxy<T>
 vnl_matlab_print(T const &obj,
-                 char const *name = 0,
+                 char const *name = VXL_NULLPTR,
                  vnl_matlab_print_format format = vnl_matlab_print_format_default)
 {
   return vnl_matlab_print_proxy<T>(obj, name, format);
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_matlab_read.h b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_matlab_read.h
index 788c583ab8..5e56ac93d4 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_matlab_read.h
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_matlab_read.h
@@ -33,8 +33,8 @@ template <class T> class vnl_matrix;
 // If the data in the file cannot reasonably be read into the destination, abort().
 //
 // The vector/matrix will be resized if necessary.
-template <class T> VNL_TEMPLATE_EXPORT bool vnl_matlab_read_or_die(std::istream &, vnl_vector<T> &, char const *name =0);
-template <class T> VNL_TEMPLATE_EXPORT bool vnl_matlab_read_or_die(std::istream &, vnl_matrix<T> &, char const *name =0);
+template <class T> VNL_TEMPLATE_EXPORT bool vnl_matlab_read_or_die(std::istream &, vnl_vector<T> &, char const *name =VXL_NULLPTR);
+template <class T> VNL_TEMPLATE_EXPORT bool vnl_matlab_read_or_die(std::istream &, vnl_matrix<T> &, char const *name =VXL_NULLPTR);
 
 // ------------------------------ less easy ------------------------------
 
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_matrix_fixed_ref.hxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_matrix_fixed_ref.hxx
index a48b31f269..5f276ef576 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_matrix_fixed_ref.hxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_matrix_fixed_ref.hxx
@@ -536,7 +536,7 @@ vnl_matrix_fixed_ref<T,nrows,ncols>::read_ascii(std::istream& s) const
 
 template <class T, unsigned nrows, unsigned ncols>
 vnl_matrix_fixed_ref<T,nrows,ncols> &
-vnl_matrix_fixed_ref<T,nrows,ncols>::flipud() 
+vnl_matrix_fixed_ref<T,nrows,ncols>::flipud()
 {
   for (unsigned int r1 = 0; 2*r1+1 < nrows; ++r1)
   {
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_numeric_traits.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_numeric_traits.cxx
index 72046e8162..0fc9533336 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_numeric_traits.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_numeric_traits.cxx
@@ -57,7 +57,7 @@ VXL_CONSTEXPR_VAR unsigned long long vnl_numeric_traits<unsigned long long>::one
 #endif
 
 VXL_CONSTEXPR_VAR bool vnl_numeric_traits<bool>::maxval VCL_STATIC_CONST_INIT_INT_DEFN(true);
-VXL_CONSTEXPR_VAR char vnl_numeric_traits<char>::maxval VCL_STATIC_CONST_INIT_INT_DEFN(char(255)<0?127:255);
+VXL_CONSTEXPR_VAR char vnl_numeric_traits<char>::maxval VCL_STATIC_CONST_INIT_INT_DEFN(char(255)<0?127:char(255));
 //  It is 127 when "char" is signed and 255 when "char" is unsigned.
 VXL_CONSTEXPR_VAR unsigned char vnl_numeric_traits<unsigned char>::maxval VCL_STATIC_CONST_INIT_INT_DEFN(255);
 VXL_CONSTEXPR_VAR signed char vnl_numeric_traits<signed char>::maxval VCL_STATIC_CONST_INIT_INT_DEFN(127);
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_random.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_random.cxx
index cd3e202c38..8cdb8f8582 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_random.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_random.cxx
@@ -89,7 +89,7 @@ void vnl_random::reseed(unsigned long seed)
   for (int j=0;j<1000;j++) lrand32();
 }
 
-void vnl_random::reseed(unsigned long seed[vnl_random_array_size])
+void vnl_random::reseed(const unsigned long seed[vnl_random_array_size])
 {
   mz_array_position = 0UL;
   mz_borrow = 0L;
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_random.h b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_random.h
index faaa00a187..de5391ac8a 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_random.h
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_random.h
@@ -81,7 +81,7 @@ class VNL_EXPORT vnl_random
     void reseed(unsigned long);
 
     //: Starts a new deterministic sequence from an already declared generator using the provided seed.
-    void reseed(unsigned long[vnl_random_array_size]);
+    void reseed(const unsigned long[vnl_random_array_size]);
 
     //: This restarts the sequence of random numbers.
     //  Restarts so that it repeats
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_rational.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_rational.cxx
index a43759f0ab..293fd07b87 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_rational.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_rational.cxx
@@ -6,9 +6,8 @@
 #include <vnl/vnl_numeric_traits.h> // for vnl_numeric_traits<long>::maxval
 #include <vcl_cassert.h>
 
-//: Creates a rational from a double.
-//  This is done by computing the continued fraction approximation for d.
-vnl_rational::vnl_rational(double d)
+template<typename FloatingType>
+inline void makeNumDen( FloatingType d, long &num_, long &den_)
 {
   bool sign = d<0;
   if (sign) d = -d;
@@ -29,6 +28,20 @@ vnl_rational::vnl_rational(double d)
   // no need to normalize() since prev_num and prev_den have guaranteed a gcd=1
 }
 
+//: Creates a rational from a double.
+//  This is done by computing the continued fraction approximation for d.
+vnl_rational::vnl_rational(double d)
+{
+  makeNumDen<double>(d,num_,den_);
+}
+
+//: Creates a rational from a double.
+//  This is done by computing the continued fraction approximation for d.
+vnl_rational::vnl_rational(float f)
+{
+  makeNumDen<double>(f,num_,den_);
+}
+
 //: Multiply/assign: replace lhs by lhs * rhs
 //  Note that 0 * Inf and Inf * 0 are undefined.
 //  Also note that there could be integer overflow during this calculation!
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_rational.h b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_rational.h
index f36caab39a..9afa439ee5 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_rational.h
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_rational.h
@@ -80,21 +80,45 @@ class VNL_EXPORT vnl_rational
   //  Also serves as automatic cast from long to vnl_rational.
   //  The only input which is not allowed is (0,0);
   //  the denominator is allowed to be 0, to represent +Inf or -Inf.
-  inline vnl_rational(long num = 0L, long den = 1L)
+
+  inline vnl_rational()
+    : num_(0L), den_(1L) { normalize(); }
+
+  inline vnl_rational(long num)
+    : num_(num), den_(1L) { assert(num!=0||den_!=0); normalize(); }
+  inline vnl_rational(long num, long den)
     : num_(num), den_(den) { assert(num!=0||den!=0); normalize(); }
-  //: Creates a rational with given numerator and denominator.
-  //  Note these are not automatic type conversions because of a bug
-  //  in the Borland compiler.  Since these just convert their
-  //  arguments to long anyway, there is no harm in letting
-  //  the long overload be used for automatic conversions.
-  explicit inline vnl_rational(int num, int den = 1)
+
+  inline vnl_rational(unsigned long num)
+    : num_(num), den_(1L) { assert(num!=0||den_!=0); normalize(); }
+  inline vnl_rational(unsigned long num, unsigned long den)
+    : num_(num), den_(den) { assert(num!=0||den!=0); normalize(); }
+
+  inline vnl_rational(int num)
+    : num_(num), den_(1L) { assert(num!=0||den_!=0); normalize(); }
+  inline vnl_rational(int num, int den)
     : num_(num), den_(den) { assert(num!=0||den!=0); normalize(); }
-  explicit inline vnl_rational(unsigned int num, unsigned int den = 1)
+
+  inline vnl_rational(unsigned int num)
+    : num_((long)num), den_(1L) { assert(num!=0||den_!=0); normalize(); }
+  inline vnl_rational(unsigned int num, unsigned int den)
     : num_((long)num), den_((long)den) { assert(num!=0||den!=0); normalize(); }
+
+  inline vnl_rational(short num)
+    : num_(num), den_(1L) { assert(num!=0||den_!=0); normalize(); }
+  inline vnl_rational(short num, short den)
+    : num_(num), den_(den) { assert(num!=0||den!=0); normalize(); }
+
+  inline vnl_rational(unsigned short num)
+    : num_(num), den_(1L) { assert(num!=0||den_!=0); normalize(); }
+  inline vnl_rational(unsigned short num, unsigned short den)
+    : num_(num), den_(den) { assert(num!=0||den!=0); normalize(); }
+
   //: Creates a rational from a double.
   //  This is done by computing the continued fraction approximation for d.
   //  Note that this is explicitly \e not an automatic type conversion.
-  explicit vnl_rational(double d);
+  vnl_rational(double d);
+  vnl_rational(float d);
   //  Copy constructor
   inline vnl_rational(vnl_rational const& from)
     : num_(from.numerator()), den_(from.denominator()) {}
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sample.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sample.cxx
index e699962126..9d5d745436 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sample.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sample.cxx
@@ -11,7 +11,7 @@
 #include <vcl_compiler.h>
 #include <vxl_config.h>
 
-#include <stdlib.h> // dont_vxl_filter
+#include <cstdlib> // dont_vxl_filter
 
 #if !VXL_STDLIB_HAS_DRAND48
 // rand() is not always a good random number generator,
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sparse_matrix.h b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sparse_matrix.h
index a3429de673..d012cf7b73 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sparse_matrix.h
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sparse_matrix.h
@@ -94,7 +94,7 @@ class VNL_TEMPLATE_EXPORT vnl_sparse_matrix_pair
     return *this;
   }
 
-  struct less : public std::binary_function<vnl_sparse_matrix_pair, vnl_sparse_matrix_pair, bool>
+  struct less
   {
     bool operator() (vnl_sparse_matrix_pair const& p1, vnl_sparse_matrix_pair const& p2) {
       return p1.first < p2.first;
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sparse_matrix_linear_system.cxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sparse_matrix_linear_system.cxx
index 7584d8da9e..608b488339 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sparse_matrix_linear_system.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sparse_matrix_linear_system.cxx
@@ -77,6 +77,6 @@ void vnl_sparse_matrix_linear_system<T>::apply_preconditioner(vnl_vector<double>
   px = dot_product(x,jacobi_precond_);
 }
 
-template class VNL_EXPORT vnl_sparse_matrix_linear_system<double>;
-template class VNL_EXPORT vnl_sparse_matrix_linear_system<float>;
+template class vnl_sparse_matrix_linear_system<double>;
+template class vnl_sparse_matrix_linear_system<float>;
 
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sparse_matrix_linear_system.h b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sparse_matrix_linear_system.h
index 8fbe755e74..091425bd8f 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sparse_matrix_linear_system.h
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sparse_matrix_linear_system.h
@@ -35,8 +35,6 @@ class VNL_TEMPLATE_EXPORT vnl_sparse_matrix_linear_system : public vnl_linear_sy
   vnl_sparse_matrix_linear_system(vnl_sparse_matrix<T> const& A, vnl_vector<T> const& b) :
     vnl_linear_system(A.columns(), A.rows()), A_(A), b_(b), jacobi_precond_() {}
 
-  virtual ~vnl_sparse_matrix_linear_system() {}
-
   //:  Implementations of the vnl_linear_system virtuals.
   void multiply(vnl_vector<double> const& x, vnl_vector<double> & b) const;
   //:  Implementations of the vnl_linear_system virtuals.
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sse.h b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sse.h
index e06ef30d33..bfc4a3a733 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sse.h
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sse.h
@@ -77,8 +77,8 @@
 # define VNL_SSE_HEAP_STORE(pf) _mm_storeu_##pf
 # define VNL_SSE_HEAP_LOAD(pf) _mm_loadu_##pf
 # if VNL_CONFIG_THREAD_SAFE
-#   define VNL_SSE_ALLOC(n,s,a) new char[n*s]
-#   define VNL_SSE_FREE(v,n,s) delete [] static_cast<char*>(v)
+#   define VNL_SSE_ALLOC(n,s,a) new char[(n)*(s)]
+#   define VNL_SSE_FREE(v,n,s) (delete [] static_cast<char*>(v))
 # else
 #   define VNL_SSE_ALLOC(n,s,a) vnl_alloc::allocate((n == 0) ? 8 : (n * s));
 #   define VNL_SSE_FREE(v,n,s) if (v) vnl_alloc::deallocate(v, (n == 0) ? 8 : (n * s));
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sym_matrix.h b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sym_matrix.h
index d1adbb1d8a..3922fca8eb 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sym_matrix.h
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_sym_matrix.h
@@ -29,7 +29,7 @@ class VNL_TEMPLATE_EXPORT vnl_sym_matrix
 {
  public:
   //: Construct an empty symmetric matrix.
-  vnl_sym_matrix(): data_(0), index_(0), nn_(0) {}
+  vnl_sym_matrix(): data_(VXL_NULLPTR), index_(VXL_NULLPTR), nn_(0) {}
 
   //: Construct a symmetric matrix of size nn by nn.
   explicit vnl_sym_matrix(unsigned nn):
@@ -222,7 +222,7 @@ inline vnl_sym_matrix<T>::vnl_sym_matrix(vnl_matrix<T> const& that):
 
 template <class T>
 inline vnl_sym_matrix<T>::vnl_sym_matrix(vnl_sym_matrix<T> const& that):
-  data_(0), index_(0), nn_(0)
+  data_(VXL_NULLPTR), index_(VXL_NULLPTR), nn_(0)
 {
   set_size(that.rows());
   update(that);
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_vector.h b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_vector.h
index 3fb0a9207f..5053a4e172 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_vector.h
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_vector.h
@@ -134,7 +134,7 @@ class VNL_TEMPLATE_EXPORT vnl_vector
   vnl_vector(vnl_vector<T> const &, vnl_matrix<T> const &, vnl_tag_mul); // v * M
   vnl_vector(vnl_vector<T> &that, vnl_tag_grab)
     : num_elmts(that.num_elmts), data(that.data)
-  { that.num_elmts=0; that.data=0; } // "*this" now uses "that"'s data.
+  { that.num_elmts=0; that.data=VXL_NULLPTR; } // "*this" now uses "that"'s data.
 // </internal>
 #endif
 
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_vector.hxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_vector.hxx
index 0e995a8ce3..1af97626ca 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_vector.hxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_vector.hxx
@@ -65,7 +65,7 @@
 #define vnl_vector_alloc_blah(size) \
 do { \
   this->num_elmts = (size); \
-  this->data = size ? vnl_c_vector<T>::allocate_T(size) : 0; \
+  this->data = (size) ? vnl_c_vector<T>::allocate_T(size) : 0; \
 } while (false)
 
 // This macro deallocates the dynamic storage used by a vnl_vector.
@@ -288,7 +288,7 @@ void vnl_vector<T>::clear()
   if (data) {
     destroy();
     num_elmts = 0;
-    data = 0;
+    data = VXL_NULLPTR;
   }
 }
 
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_vector_fixed_ref.hxx b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_vector_fixed_ref.hxx
index 7317b90c72..13879ea79a 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_vector_fixed_ref.hxx
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vnl/vnl_vector_fixed_ref.hxx
@@ -123,7 +123,7 @@ vnl_vector_fixed_ref_const<T,n>::print( std::ostream& s ) const
 // instantiation macros for vnl_vector_fixed_ref<T,unsigned> :
 
 #define VNL_VECTOR_FIXED_REF_INSTANTIATE(T,n) \
-template class VNL_EXPORT vnl_vector_fixed_ref<T, n >; \
-template class VNL_EXPORT vnl_vector_fixed_ref_const<T, n >
+template class vnl_vector_fixed_ref<T, n >; \
+template class vnl_vector_fixed_ref_const<T, n >
 
 #endif // vnl_vector_fixed_ref_hxx_
diff --git a/Modules/ThirdParty/VNL/src/vxl/core/vxl_version.h b/Modules/ThirdParty/VNL/src/vxl/core/vxl_version.h
index 152aeab849..a37ecc38b7 100644
--- a/Modules/ThirdParty/VNL/src/vxl/core/vxl_version.h
+++ b/Modules/ThirdParty/VNL/src/vxl/core/vxl_version.h
@@ -26,9 +26,9 @@
 
 //: Version date.  This is updated every day.
 // Formats are year=CCYY, month=MM, day=DD
-#define VXL_VERSION_DATE_YEAR 2017
-#define VXL_VERSION_DATE_MONTH 12
-#define VXL_VERSION_DATE_DAY 08
+#define VXL_VERSION_DATE_YEAR 2018
+#define VXL_VERSION_DATE_MONTH 05
+#define VXL_VERSION_DATE_DAY 16
 
 //: Helper macros to create strings with the preprocessor.
 #define VXL_VERSION_TO_STRING(s) VXL_VERSION_TO_STRING0(s)
diff --git a/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/CMakeLists.txt b/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/CMakeLists.txt
index 431bbae68a..f9f4816083 100644
--- a/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/CMakeLists.txt
+++ b/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/CMakeLists.txt
@@ -445,7 +445,6 @@ if(BUILD_TESTING)
   add_subdirectory(tests)
 endif()
 
-# Disabled in ITK to avoid find_package(X11)
-if(BUILD_EXAMPLES AND 0)
+if(BUILD_EXAMPLES)
   add_subdirectory(examples)
 endif()
diff --git a/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/libf2c/comptry.bat b/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/libf2c/comptry.bat
index 2ae4565113..0dc84531c9 100755
--- a/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/libf2c/comptry.bat
+++ b/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/libf2c/comptry.bat
@@ -1,5 +1,5 @@
-%1 %2 %3 %4 %5 %6 %7 %8 %9
-if errorlevel 1 goto nolonglong
-exit 0
-:nolonglong
-%1 -DNO_LONG_LONG %2 %3 %4 %5 %6 %7 %8 %9
+%1 %2 %3 %4 %5 %6 %7 %8 %9
+if errorlevel 1 goto nolonglong
+exit 0
+:nolonglong
+%1 -DNO_LONG_LONG %2 %3 %4 %5 %6 %7 %8 %9
diff --git a/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/libf2c/scomptry.bat b/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/libf2c/scomptry.bat
index 69be841b91..2c11a97e45 100755
--- a/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/libf2c/scomptry.bat
+++ b/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/libf2c/scomptry.bat
@@ -1,5 +1,5 @@
-%1 -DWRITE_ARITH_H -DNO_FPINIT %2 %3 %4 %5 %6 %7 %8 %9
-if errorlevel 1 goto nolonglong
-exit 0
-:nolonglong
-%1 -DNO_LONG_LONG -DWRITE_ARITH_H -DNO_FPINIT %2 %3 %4 %5 %6 %7 %8 %9
+%1 -DWRITE_ARITH_H -DNO_FPINIT %2 %3 %4 %5 %6 %7 %8 %9
+if errorlevel 1 goto nolonglong
+exit 0
+:nolonglong
+%1 -DNO_LONG_LONG -DWRITE_ARITH_H -DNO_FPINIT %2 %3 %4 %5 %6 %7 %8 %9
diff --git a/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/linalg/lsmrBase.cxx b/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/linalg/lsmrBase.cxx
index 6053b93203..067b1abebb 100644
--- a/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/linalg/lsmrBase.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/linalg/lsmrBase.cxx
@@ -16,6 +16,7 @@
  *
  *=========================================================================*/
 #include "lsmrBase.h"
+#include "vcl_compiler_detection.h"
 
 #include <algorithm>
 #include <cmath>
@@ -40,7 +41,7 @@ lsmrBase::lsmrBase()
   this->btol = 1e-6;
   this->conlim = 1.0 / ( 10 * sqrt( this->eps ) );
   this->itnlim = 10;
-  this->nout = NULL;
+  this->nout = VXL_NULLPTR;
   this->istop = 0;
   this->itn = 0;
   this->normA = 0.0;
diff --git a/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/linalg/lsmrDense.cxx b/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/linalg/lsmrDense.cxx
index 799bc0538b..b0ccf84890 100644
--- a/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/linalg/lsmrDense.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/linalg/lsmrDense.cxx
@@ -16,10 +16,11 @@
  *
  *=========================================================================*/
 #include "lsmrDense.h"
+#include "vcl_compiler_detection.h"
 
 lsmrDense::lsmrDense()
 {
-  this->A = 0;
+  this->A = VXL_NULLPTR;
 }
 
 
diff --git a/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/linalg/lsqrDense.cxx b/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/linalg/lsqrDense.cxx
index c62c3953a8..8d55fc088a 100644
--- a/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/linalg/lsqrDense.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/linalg/lsqrDense.cxx
@@ -17,10 +17,11 @@
  *=========================================================================*/
 
 #include "lsqrDense.h"
+#include "vcl_compiler_detection.h"
 
 lsqrDense::lsqrDense()
 {
-  this->A = 0;
+  this->A = VXL_NULLPTR;
 }
 
 
diff --git a/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/sparse/spMatrix.h b/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/sparse/spMatrix.h
index 38300975a4..c30ff15ac8 100644
--- a/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/sparse/spMatrix.h
+++ b/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/sparse/spMatrix.h
@@ -175,15 +175,15 @@
  * Macro function that adds data to a imaginary element in the matrix by
  * a pointer.
  */
-#define  spADD_IMAG_ELEMENT(element,imag)       *(element+1) += imag
+#define  spADD_IMAG_ELEMENT(element,imag)       *((element)+1) += imag
 
 /*!
  * Macro function that adds data to a complex element in the matrix by
  * a pointer.
  */
 #define  spADD_COMPLEX_ELEMENT(element,real,imag)       \
-{   *(element) += real;                                 \
-    *(element+1) += imag;                               \
+{   *(element) += (real);                                 \
+    *((element)+1) += (imag);                               \
 }
 
 /*!
@@ -191,10 +191,10 @@
  * specified by the given template.
  */
 #define  spADD_REAL_QUAD(template,real)         \
-{   *((template).Element1) += real;             \
-    *((template).Element2) += real;             \
-    *((template).Element3Negated) -= real;      \
-    *((template).Element4Negated) -= real;      \
+{   *((template).Element1) += (real);             \
+    *((template).Element2) += (real);             \
+    *((template).Element3Negated) -= (real);      \
+    *((template).Element4Negated) -= (real);      \
 }
 
 /*!
@@ -202,10 +202,10 @@
  * elements specified by the given template.
  */
 #define  spADD_IMAG_QUAD(template,imag)         \
-{   *((template).Element1+1) += imag;           \
-    *((template).Element2+1) += imag;           \
-    *((template).Element3Negated+1) -= imag;    \
-    *((template).Element4Negated+1) -= imag;    \
+{   *((template).Element1+1) += (imag);           \
+    *((template).Element2+1) += (imag);           \
+    *((template).Element3Negated+1) -= (imag);    \
+    *((template).Element4Negated+1) -= (imag);    \
 }
 
 /*!
@@ -213,14 +213,14 @@
  * elements specified by the given template.
  */
 #define  spADD_COMPLEX_QUAD(template,real,imag) \
-{   *((template).Element1) += real;             \
-    *((template).Element2) += real;             \
-    *((template).Element3Negated) -= real;      \
-    *((template).Element4Negated) -= real;      \
-    *((template).Element1+1) += imag;           \
-    *((template).Element2+1) += imag;           \
-    *((template).Element3Negated+1) -= imag;    \
-    *((template).Element4Negated+1) -= imag;    \
+{   *((template).Element1) += (real);             \
+    *((template).Element2) += (real);             \
+    *((template).Element3Negated) -= (real);      \
+    *((template).Element4Negated) -= (real);      \
+    *((template).Element1+1) += (imag);           \
+    *((template).Element2+1) += (imag);           \
+    *((template).Element3Negated+1) -= (imag);    \
+    *((template).Element4Negated+1) -= (imag);    \
 }
 
 /*
diff --git a/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/triangle.c b/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/triangle.c
index e9b55d33d5..b11058fd9d 100644
--- a/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/triangle.c
+++ b/Modules/ThirdParty/VNL/src/vxl/v3p/netlib/triangle.c
@@ -9232,6 +9232,8 @@ int arraysize;
   }
   /* Choose a random pivot to split the array. */
   pivot = (int) randomnation((unsigned int) arraysize);
+  if (pivot == arraysize)//JLM without this test, pivot can equal arraysize and segfault
+	  pivot--;
   pivotx = sortarray[pivot][0];
   pivoty = sortarray[pivot][1];
   /* Split the array. */
@@ -9308,6 +9310,8 @@ int axis;
   }
   /* Choose a random pivot to split the array. */
   pivot = (int) randomnation((unsigned int) arraysize);
+  if (pivot == arraysize)//JLM/SES without this test, pivot can equal arraysize and segfault
+	  pivot--;
   pivot1 = sortarray[pivot][axis];
   pivot2 = sortarray[pivot][1 - axis];
   /* Split the array. */
diff --git a/Modules/ThirdParty/VNL/src/vxl/vcl/CMakeLists.txt b/Modules/ThirdParty/VNL/src/vxl/vcl/CMakeLists.txt
index 89e2b99f71..fed3b8e268 100644
--- a/Modules/ThirdParty/VNL/src/vxl/vcl/CMakeLists.txt
+++ b/Modules/ThirdParty/VNL/src/vxl/vcl/CMakeLists.txt
@@ -73,7 +73,7 @@ if( VXL_MANUAL_GENERATE_NEW_COMPILER_DETECTION_HEADERS )
         cxx_long_long_type                      # long long type, as defined in N1811.
         cxx_noexcept                            # Exception specifications, as defined in N3050.
         cxx_nonstatic_member_init               # Non-static data member initialization, as defined in N2756.
-        cxx_nullptr                             # Null pointer, as defined in N2431.
+        cxx_VXL_NULLPTR                             # Null pointer, as defined in N2431.
         cxx_override                            # Override control override keyword, as defined in N2928, N3206 and N3272.
         cxx_range_for                           # Range-based for, as defined in N2930.
         cxx_raw_string_literals                 # Raw string literals, as defined in N2442.
diff --git a/Modules/ThirdParty/VNL/src/vxl/vcl/compilers/VXL_COMPILER_INFO_AppleClang_CXX.h b/Modules/ThirdParty/VNL/src/vxl/vcl/compilers/VXL_COMPILER_INFO_AppleClang_CXX.h
index 196ab2d503..7ff70236c4 100644
--- a/Modules/ThirdParty/VNL/src/vxl/vcl/compilers/VXL_COMPILER_INFO_AppleClang_CXX.h
+++ b/Modules/ThirdParty/VNL/src/vxl/vcl/compilers/VXL_COMPILER_INFO_AppleClang_CXX.h
@@ -226,7 +226,7 @@
 #      define VXL_COMPILER_CXX_NONSTATIC_MEMBER_INIT 0
 #    endif
 
-#    if ((__clang_major__ * 100) + __clang_minor__) >= 400 && __has_feature(cxx_nullptr)
+#    if ((__clang_major__ * 100) + __clang_minor__) >= 400 && __has_feature(cxx_VXL_NULLPTR)
 #      define VXL_COMPILER_CXX_NULLPTR 1
 #    else
 #      define VXL_COMPILER_CXX_NULLPTR 0
diff --git a/Modules/ThirdParty/VNL/src/vxl/vcl/compilers/VXL_COMPILER_INFO_Clang_CXX.h b/Modules/ThirdParty/VNL/src/vxl/vcl/compilers/VXL_COMPILER_INFO_Clang_CXX.h
index 752ad86223..cae90561d2 100644
--- a/Modules/ThirdParty/VNL/src/vxl/vcl/compilers/VXL_COMPILER_INFO_Clang_CXX.h
+++ b/Modules/ThirdParty/VNL/src/vxl/vcl/compilers/VXL_COMPILER_INFO_Clang_CXX.h
@@ -225,7 +225,7 @@
 #      define VXL_COMPILER_CXX_NONSTATIC_MEMBER_INIT 0
 #    endif
 
-#    if ((__clang_major__ * 100) + __clang_minor__) >= 301 && __has_feature(cxx_nullptr)
+#    if ((__clang_major__ * 100) + __clang_minor__) >= 301 && __has_feature(cxx_VXL_NULLPTR)
 #      define VXL_COMPILER_CXX_NULLPTR 1
 #    else
 #      define VXL_COMPILER_CXX_NULLPTR 0
diff --git a/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_atomic_count.cxx b/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_atomic_count.cxx
index 43ba3e5feb..605e73114a 100644
--- a/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_atomic_count.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_atomic_count.cxx
@@ -1,7 +1,7 @@
 #include <vcl_atomic_count.h>
 #include <vcl_cstdio.h>
 
-#define TEST(str,x,y) vcl_printf(str ":   "); if (x!=y) { vcl_printf("FAILED\n"); status = 1; } else { vcl_printf("PASSED\n"); }
+#define TEST(str,x,y) vcl_printf(str ":   "); if ((x)!=(y)) { vcl_printf("FAILED\n"); status = 1; } else { vcl_printf("PASSED\n"); }
 
 int test_atomic_count_main(int /*argc*/,char* /*argv*/[])
 {
diff --git a/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_cmath.cxx b/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_cmath.cxx
index 5ca2b758e6..ebc552b521 100644
--- a/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_cmath.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_cmath.cxx
@@ -24,7 +24,7 @@ int test_cmath_main(int /*argc*/,char* /*argv*/[])
 
 #define macro(var, type) \
 do { \
-  if (vcl_abs(var) == var && vcl_abs(- var) == var) \
+  if (vcl_abs(var) == (var) && vcl_abs(- (var)) == (var)) \
     vcl_cout << "vcl_abs(" #type ") PASSED" << vcl_endl; \
   else \
     vcl_cerr << "vcl_abs(" #type ") *** FAILED *** " << vcl_endl; \
@@ -58,7 +58,7 @@ do { \
   do { \
     T x = 2; \
     T y = vcl_sqrt(x); \
-    if (vcl_abs(x - y*y) < eps) \
+    if (vcl_abs(x - y*y) < (eps)) \
       vcl_cout << "vcl_sqrt(" #T ") PASSED" << vcl_endl; \
     else \
       vcl_cout << "vcl_sqrt(" #T ") *** FAILED *** " << vcl_endl; \
diff --git a/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_limits.cxx b/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_limits.cxx
index 4d4fb1aa24..40ed03dd02 100644
--- a/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_limits.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_limits.cxx
@@ -49,8 +49,8 @@ void test_static_const_definition()
 #undef TEST_TYPE
 }
 
-#define TEST(m,x,y)    if ((x)!=(y)) { vcl_cout<< "FAIL: " << m << '\n'; fail=true; } \
-                       else { vcl_cout<< "PASS: " << m << '\n'; }
+#define TEST(m,x,y)    if ((x)!=(y)) { vcl_cout<< "FAIL: " << (m) << '\n'; fail=true; } \
+                       else { vcl_cout<< "PASS: " << (m) << '\n'; }
 
 int test_limits_main(int /*argc*/, char* /*argv*/[])
 {
diff --git a/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_memory.cxx b/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_memory.cxx
index a76e92d467..b87977af9f 100644
--- a/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_memory.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_memory.cxx
@@ -14,14 +14,14 @@ struct A
 
 struct B: public A {};
 
-static int function_call(vcl_auto_ptr<A> a)
+static int function_call(vcl_unique_ptr<A> a)
 {
   return a.get()? 1:0;
 }
 
 static A* get_A(A& a) { return &a; }
 
-static vcl_auto_ptr<A> generate_auto_ptr () { return vcl_auto_ptr<A>(new A); }
+static vcl_unique_ptr<A> generate_auto_ptr () { return vcl_unique_ptr<A>(new A); }
 
 int test_memory_main(int /*argc*/,char* /*argv*/[])
 {
@@ -29,11 +29,11 @@ int test_memory_main(int /*argc*/,char* /*argv*/[])
 
   // Keep everything in a subscope so we can detect leaks.
   {
-    vcl_auto_ptr<A> pa0;
-    vcl_auto_ptr<A> pa1(new A());
-    vcl_auto_ptr<B> pb1(new B());
-    vcl_auto_ptr<A> pa2(new B());
-    vcl_auto_ptr<A> pa3(pb1);
+    vcl_unique_ptr<A> pa0;
+    vcl_unique_ptr<A> pa1(new A());
+    vcl_unique_ptr<B> pb1(new B());
+    vcl_unique_ptr<A> pa2(new B());
+    vcl_unique_ptr<A> pa3(vcl_move(pb1));
 
     A* ptr = get_A(*pa1);
     ASSERT(ptr == pa1.get(),
@@ -55,12 +55,12 @@ int test_memory_main(int /*argc*/,char* /*argv*/[])
     delete pa0.release();
     ASSERT(!pa0.get(), "auto_ptr holds an object after release()");
 
-    pa1 = pa3;
+    pa1 = vcl_move(pa3);
     ASSERT(!pa3.get(), "auto_ptr holds an object after assignment to another");
     ASSERT(pa1.get(),
            "auto_ptr does not hold an object after assignment from another");
 
-    int copied = function_call(pa2);
+    int copied = function_call(vcl_move(pa2));
     ASSERT(copied, "auto_ptr did not receive ownership in called function");
     ASSERT(!pa2.get(), "auto_ptr did not release ownership to called function");
 
diff --git a/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_sstream.cxx b/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_sstream.cxx
index 32e454954d..9bbbe02526 100644
--- a/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_sstream.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_sstream.cxx
@@ -2,7 +2,7 @@
 #include <vcl_iostream.h>
 #include <vcl_sstream.h>
 
-#define AssertEq(x,y) {status+=((x)==(y))?0:1;vcl_cout<<"TEST ["<<x<<"] == ["<<y<<"] : "<<((x)==(y)?"PASSED":"FAILED")<<vcl_endl;}
+#define AssertEq(x,y) {status+=((x)==(y))?0:1;vcl_cout<<"TEST ["<<(x)<<"] == ["<<(y)<<"] : "<<((x)==(y)?"PASSED":"FAILED")<<vcl_endl;}
 
 int test_sstream_main(int /*argc*/,char* /*argv*/[])
 {
diff --git a/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_string.cxx b/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_string.cxx
index 0ffc88471e..89206a102e 100644
--- a/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_string.cxx
+++ b/Modules/ThirdParty/VNL/src/vxl/vcl/tests/test_string.cxx
@@ -3,7 +3,7 @@
 
 #define Assert(x) {vcl_cout << "TEST " #x " : "; vcl_cout << ((x)?"PASSED":"FAILED")}
 
-#define AssertEq(x) {vcl_cout<<"TEST ["<<fred<<"] == ["<<x<<"] : ";vcl_cout<<(fred==(x)?"PASSED":"FAILED")<<vcl_endl;}
+#define AssertEq(x) {vcl_cout<<"TEST ["<<fred<<"] == ["<<(x)<<"] : ";vcl_cout<<(fred==(x)?"PASSED":"FAILED")<<vcl_endl;}
 
 int test_string_main(int /*argc*/,char* /*argv*/[])
 {
diff --git a/Modules/ThirdParty/VNL/src/vxl/vcl/vcl_compiler.h b/Modules/ThirdParty/VNL/src/vxl/vcl/vcl_compiler.h
index 3f1bb01144..5ca624603d 100644
--- a/Modules/ThirdParty/VNL/src/vxl/vcl/vcl_compiler.h
+++ b/Modules/ThirdParty/VNL/src/vxl/vcl/vcl_compiler.h
@@ -86,6 +86,17 @@
 #  else
 #   define VCL_GCC_70
 #  endif
+# elif (__GNUC__==8)
+#  define VCL_GCC_8
+#  if (__GNUC_MINOR__ > 2 )
+#   define VCL_GCC_83
+#  elif (__GNUC_MINOR__ > 1 )
+#   define VCL_GCC_82
+#  elif (__GNUC_MINOR__ > 0 )
+#   define VCL_GCC_81
+#  else
+#   define VCL_GCC_80
+#  endif
 # else
 #  error "Dunno about this gcc"
 # endif
@@ -897,7 +908,7 @@ __inline int vcl_snprintf(char *outBuf, size_t size, const char *format, ...)
 #define vcl_uninitialized_copy std::uninitialized_copy
 #define vcl_uninitialized_fill std::uninitialized_fill
 #define vcl_uninitialized_fill_n std::uninitialized_fill_n
-#define vcl_auto_ptr std::auto_ptr
+#define vcl_auto_ptr vcl_auto_ptr
 #define vcl_bad_alloc std::bad_alloc
 #define vcl_set_new_handler std::set_new_handler
 #define vcl_accumulate std::accumulate
diff --git a/Modules/ThirdParty/VNL/src/vxl/vcl/vcl_memory.h b/Modules/ThirdParty/VNL/src/vxl/vcl/vcl_memory.h
index b15a5f4368..da038dd721 100644
--- a/Modules/ThirdParty/VNL/src/vxl/vcl/vcl_memory.h
+++ b/Modules/ThirdParty/VNL/src/vxl/vcl/vcl_memory.h
@@ -2,6 +2,19 @@
 #define vcl_memory_h_
 
 #include <memory>
+#include  <utility>
 #include "vcl_compiler.h"
 
+// Needed to provide backwards compatibility between C++11 and older compilers
+// https://softwareengineering.stackexchange.com/questions/291141/how-to-handle-design-changes-for-auto-ptr-deprecation-in-c11
+#if __cplusplus >= 201103L || (defined(_CPPLIB_VER) && _CPPLIB_VER > 540)
+    template <typename T>
+    using vcl_unique_ptr = std::unique_ptr<T>;
+    #define vcl_move( value ) std::move(value)
+#else
+// NOTE:  THIS DOES NOT MEET THE STANDARDS FOR A UNIQUE POINTER!
+#   define vcl_unique_ptr std::auto_ptr
+#   define vcl_move( value ) value
+#endif
+
 #endif // vcl_memory_h_
