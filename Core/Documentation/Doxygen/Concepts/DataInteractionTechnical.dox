/**

\page DataInteractionTechnicalPage Interaction Concept Implementation

\tableofcontents

\section DataInteractionTechnicalPage_Introduction Description of Interaction Concept Implementation in MITK


\section DispatcherSection Dispatcher

Each BaseRenderer creates a mitk::BindDispatcherInteractor object which encapsulates the connection between the DataStorage and the Dispatcher,
and thereby allowing a DataInteractor to register with a Dispatcher when only knowing the DataNode.

BindDispatcherInteractor creates a new Dispatcher object and registers for DataNode events at the DataStorage, as a callback function the
Dispatchers AddDataInteractor() and RemoveDataInteractor() functions are set.

\dot
digraph {
  node [shape=record, fontname=Helvetica, fontsize=10];
  a [ label="{BaseRenderer|m_BindDispatcherInteractor}"];
  b [ label="{BindDispatcherInteractor|m_Dispatcher\n m_DataStorage}" ];
  c [ label="Dispatcher" ];
  d [ label="DataStorage" ];
  a -> b;
  b -> c;
  b -> d;
}
\enddot

This way the Dispatcher is notified about all changes regarding
DataNodes that are shown in the BaseRenderer. When a node is added, remove or modified the Dispatcher can check it a DataInterator is set,
and accordingly add or remove this DataInteractor from its internal list.

\dot
digraph {
  node [shape=record, fontname=Helvetica, fontsize=10];
  d [ label="DataInteractor" ];
  a [ label="DataNode" ];
  b [ label="DataStorage" ];
  c [ label="Dispatcher" ];
  e [ label="BaseRenderer"]
  edge [fontname=Helvetica, fontsize=10]
  d -> a [label="SetDataInteractor(this)"];
  a -> b [label="Modified()"];
  b -> c [label="NodeModified(dataNode)"];
  e -> c [label="HandleEvent(interactionEvent)"];
 { rank=same; b c a }
 { rank=same; e }
}
\enddot

Events that are generated within the scope of the BaseRenderer are sent to the associated Dispatcher to be handled.


\subsection DispatcherEventDistSection Event Distribution

 A Dispatcher can operate in different processing modes, which determine how the interactor that receives an event is chosen.
 These modes are managed and set by the Dispatcher itself.

<ul>
 <li> \b Regular: \n
    DataInteractors are sorted by their layer, and distribution is stared with the top-most.

 <li> \bConnected \b Mouse \b Action:

      A connected mouse action is described by the sequence of Mouse-Press, (optionally) Mouse-Move , Mouse-Release Events.\n
      Within this sequence all events are sent to the same DateInteractor, the one which received the event from the Mouse-Press action.\n
      \b m_ConnectedMouseAction  - is set to true, when a Mouse-Down Event occurs and a DataInterator takes the event and
      \b m_SelectedInteractor is then set to this DataInteractor.\n
      \b m_ConnectedMouseAction is reset to false, after the Mouse-Release Event occurs,\n
      while it is true, the m_SelectedInteractor is the only one that receives Mouse-Events.

 <li> \b Grab \b Input:\n
      Whenever a DataInteractor performs a state change into a state that is marked by the grab input-tag, the Dispatcher switches into this mode.
      As long as it is in this mode ONLY the selected DataInteractor will receive the event. This mode is ended when the DataInteractor switches back to
      a state without a tag/ or the REGULAR-tag.\n
      \note In this mode EventObservers will NOT receive the events.

   <li> \b Prefer \b Input: \n
      Basically works as Grab Input, with the difference that if the Interactor in an prefer input state, cannot process the event offered,
      it will be offered to the other interactors in the regular way.\n
      In this mode EventObservers ARE informed.

</ul>
\section StateMachineSection State Machine & Configuration

A  mitk::EventStateMachine points to a \b state, which in turn references  \b transitions
(which describe a change from one state to another) and \b actions (indicating which functions are executed when a transition is taken).
\dot
digraph {
  node [shape=record, fontname=Helvetica, fontsize=10];
  d [ label="{StateMachine|m_CurrentState}" ];
  a [ label="{StateMachineState|m_Transitions}" ];
  b [ label="{StateMachineTransitions|m_Actions}"];
  c [ label="{StateMachineAction}"];
  edge [fontname=Helvetica, fontsize=10]
  d -> a [label="1 : 1"];
  a -> b [label="1 : n"];
  b -> c [label="1 : n"];
}
\enddot

After an event is received by the Dispatcher it is given to a DataInteractor that has to decide if it can process this event.
On a high level this is done by the mitk::EventStateMachine.
First the state machine asks if the received event is known in the
configuration. If it does the matching variant name is returned. Then the state machine checks if there exists a transition
in its current state that is triggered by this event variant. If this is the case all actions that are associated with this transition
are queried and executed. The actions themselves are implemented on DataInteractor level. The following diagram illustrates the process:

\image html sm_and_config.png

\section ConfigFileDescriptionSection HowTo Create a Config-File

\subsection EventDescriptionSection Event Description

Events are described by their parameters. Each event type has its own set of parameters that can be set in the configuration file.
If a parameter is ommitted it is set to its default value. Following all possible parameters are listed and described, to which parameters
events have is decribed in their respective documentation.

Mandatory for each event description is the event class and the event variant. The parameters of an event are set by attribute tags.
\note Refer to \ref EventClassSection for the meaning of event class.

\b Modifier \b Keys \n

mitk::ModifierKeys represent the combination of pressed modifier keys, several modifier keys pressed at the same time
are denoted by listing them all separated by commas.

\code
<!-- shift and control key are pressed -->
<attribute name="Modifiers" value="shift,ctrl"/>
\endcode

\b Mouse \b Buttons \n

mitk::MouseButtons represent the buttons. They can be used for two attributes. First the EventButton which describes the button that triggered the event,
this allways is a single button. Secondly the ButtonState attribute that describes which buttons were pressed at the moment the event has been generated.
For example assume the right mouse button and the middle mouse button are already pressed, now also the left mouse button is pressed too and generates a second event,
this would be described as follows:

\code
<attribute name="EventButton" value="LeftMouseButton"/>
<attribute name="ButtonState" value="RightMouseButton,MiddleMouseButton"/>
\endcode

Note: Technically the LeftMouseButton is also pressed and should be listed in the ButtonState, but this is taken care of by the mitk:EventFactory .

\b ScrollDirection \n

This attribute is unique to the mitk::MouseWheelEvent and describes the direction in which the mouse wheel is rotated. In the event description actual only the direction is provided,
but the event is generated with the actual value, and this value can be retrieved from the object.

\code
 <attribute name="ScrollDirection" value="up"/>
 <!-- or -->
 <attribute name="ScrollDirection" value="down"/>
\endcode


\subsection ExamplesSection Examples


Examples for key events:
\code
<config>
  <!-- Event of key 'a' pressed -->
  <input event_class="KeyEvent" event_variant="StdA">
    <attribute name="Key" value="A"/>
  </input>
  <!-- Event of key 'b' pressed  while modifiers ctrl and shift are pressed-->
  <input event_class="KeyEvent" event_variant="StdA">
    <attribute name="Key" value="A"/>
    <attribute name="Modifiers" value="shift,ctrl"/>
  </input>
</config>
\endcode


Examples for MousePress events:
\code
 <!-- Standard left click -->
<config>
  <input event_class="MousePressEvent" event_variant="StdMousePressPrimaryButton">
    <attribute name="EventButton" value="LeftMouseButton"/>
  </input>
<!-- right click with control key pressed-->
  <input event_class="MousePressEvent" event_variant="RightWithCTRL">
    <attribute name="EventButton" value="RightMouseButton"/>
    <attribute name="Modifiers" value="ctrl"/>
  </input>
</config>
\endcode

There exists a standard configuration file for the most common events called GlobalConfig.xml that can be used to as a default and can be extended
by a specific definition.

\subsection ParameterDescriptionSection Parameter Description

It is also possible to store parameters in the config file. Those are stored using the param-tag, like this:

\code
<config name="example2">
 <param name="property1" value="yes"/>
 <param name="scrollModus" value="leftright"/>
</config>
\endcode

Within the application these properties can then be access via a mitk::PropertyList like this:

\code
  // sm - state machine loaded with config file example2

  mitk::PropertyList::Pointer properties = GetPropertyList();
  std::string prop1;
  properties->GetStringProperty("property1",prop1);
\endcode


\section HowToStateMachine HowTo Write a State Machine

A state machine pattern is described in a XML file.

\subsection StateSection States

States are described using the state-tag. Each state has to have a name. Exactly one state has to be as start state in
each state machine to indicate the state in which the state machine is set when it is constructed.
So a valid, but rather useless state machine would like like this:

\code
<statemachine>
 <state name="start" startstate="true"/>
</statemachine>
\endcode

Optionally a state can be assigned a special mode that influences the event distribution.
These modes are GRAB_INPUT , PREFER_INPUT and REGULAR (where REGULAR is default and does not need to be indicated).
See \ref DispatcherEventDistSection for a description of these modes. Use the special modes only when necessary as they prevent other DataInteractors to
receive events.

\code
<!-- example -->
<state name="someState" startstate="true" state_mode="GRAB_INPUT"/>
\endcode

\subsection TransitionSection Transitions
Transitions are part of a state and describe all possible state switches, and are therefore important for modelling an interaction scheme.
Transitions consist a part that describes the event which triggers the transition (event class and event variant) and a target which is state
to which the state machine switches after executing a transition.
An event class describes the event type (see mitk::InteractionEvent for the different classes) and the event variant is a specification thereof
and the exact description is taken from  a config file. Together they determine which event can trigger this transition.
For example this state machine will switch from state A to state B when the StdMousePressPrimaryButton event (left mouse button is pressed) occurs.

\subsubsection EventClassSection Event Class
The event class description supports the polymorphism of the event classes. Therefore state machine patters should be written in the most
general ways possible.
So for a given class hierarchy like this:
\dot
digraph {
  node [shape=record, fontname=Helvetica, fontsize=10];
  a [ label="{PositionEvent}"];
  b [ label="{MousePressEvent}" ];
  c [ label="MouseReleaseEvent" ];
  d [ label="+TouchEvent" ];
  a -> b;
  a -> c;
  a -> d;
}
\enddot

in the state machine pattern the  PositionEvent can be declared as event class to restrict to the events which hold a position information.
The actual implementation is then given in the configuration file. In this case it allows to define event of the classes PositionEvent itself, or
MousePressEvent,MouseReleaseEvent,TouchEvent.
This has the advantage that the patterns remain the same no matter what input devices are used, and the state machine patterns can be configured
for newly added event classes as long as they match the class hierachy (this ensures they hold the neccessary properties).

\code
<statemachine>
 <state name="A" startstate="true">
   <transition event_class="MousePressEvent" event_variant="StdMousePressPrimaryButton" target="B"/>
 <state/>
 <state name="B" />
</statemachine>
\endcode

\subsection ActionSection Actions
Actions can be added to transitions and represent functions in the DataInteractor that are executed on taking a transition.
The following simple state machine will listen for left mouse clicks and execute two actions (and actually never stop).
\code
<statemachine>
    <state name="start" startstate="true">
        <transition event_class="MousePressEvent" event_variant="StdMousePressPrimaryButton" target="start">
            <action name="addPoint"/>
            <action name="countClicks"/>
        </transition>
    </state>
</statemachine>
\endcode

In order to tell the DataInteractor which function to execute these actions are made known to the DataInteractor using
the CONNECT_FUNCTION macro.  This example assumes that there exists an ExampleInteractor which inherits from DataInteractor.
This class implements the functions AddPoint and CountClicks. The actions are introduced by implementing the virtual method
ConnectActionsAndFunctions():

\code
void mitk::ExampleInteractor::ConnectActionsAndFunctions()
{
  CONNECT_FUNCTION("addPoint", AddPoint);
  CONNECT_FUNCTION("countClicks", CountClicks);
}
\endcode

\section HowToDataInteractor HowTo Implement a new DataInteractor

TODO ref PointSetInteractor / Observer -> DisplayInteractor

This HowTo assumes knowlege of the Interaction concept described in \ref DataInteractionPage , State Machines and Configuration described in
\ref StateMachineSection, \ref HOW TO Config, HOW TO StateMachine.

DataInteractor are to inherit from mitk::DataInteractor. Their functionality is implemented in functions that follow this interface:
\code
bool SomeFunctionality(StateMachineAction* , InteractionEvent*);
\endcode

Your functions are connected with actions by implementing the function ConnectActionsAndFunctions(), e.g.

\code
void mitk::ExampleInteractor::ConnectActionsAndFunctions()
{
 CONNECT_FUNCTION("addPoint", AddPoint);
 CONNECT_FUNCTION("enoughPoints", EnoughPoints);
}
\endcode

Now all that is left it to write a state machine pattern and a config file as is described in the tutorials.

\subsection ExampleInternalEvent Example Interactor using InternalEvent

A useful tool in creating DataInteractors are mitk::InternalEvents which allow to the DataInteractor send signals on its own.
The following will describe how to build a DataInteractor that allows to add points until a certain number of points is reached.
The number of accepted points is provided in the config file as a parameter.
So we start by writing a state machine pattern that add points until it receives an InternalEvent telling it, that enough points
have been added.

\code
<statemachine>
    <state name="start" startstate="true" >
        <transition event_class="MousePressEvent" event_variant="AddPointClick" target="start">
            <action name="addPoint"/>
        </transition>
        <transition event_class="InternalEvent" event_variant="SetIsFull" target="final">
            <action name="enoughPoints"/>
        </transition>
    </state>
    <state name="final">
    <!-- dead state, nothing happens any more, once we reached this -->
    </state>
</statemachine>
\endcode

In our config file we set the number of maximal points to 10, and define AddPointClick as a right mouse click with the
ctrl button pressed.
\code
<config>
  <param name="NumberOfPoints" value="10">
  <input event_class="InternalEvent" event_variant="SetIsFull">
    <attribute name="SignalName" value="enoughPointsAdded"/>
  </input>
   <input event_class="MousePressEvent" event_variant="AddPointClick">
    <attribute name="EventButton" value="RightMouseButton"/>
    <attribute name="Modifiers" value="ctrl"/>
  </input>
</config>
\endcode

The header file of the DataInteractor looks like this:

\code
#include "itkObject.h"
#include "itkSmartPointer.h"
#include "itkObjectFactory.h"
#include "mitkCommon.h"
#include <MitkExports.h>
#include "mitkDataInteractor.h"
#include <mitkPointSet.h>


namespace mitk
{
  class MITK_CORE_EXPORT ExampleInteractor: public DataInteractor
  {
  public:
    mitkClassMacro(ExampleInteractor, DataInteractor);
    itkNewMacro(Self);

  protected:
    ExampleInteractor();
    virtual ~ExampleInteractor();
    virtual void ConnectActionsAndFunctions();

  private:
    bool AddPoint(StateMachineAction* , InteractionEvent*); // function to add new points
    bool EnoughPoints(StateMachineAction* , InteractionEvent*); // function changes color of pointset to indicate, it is full
    PointSet::Pointer m_PointSet;
    int m_NumberOfPoints;
  };
}
\endcode

The header file looks like this:

\code
#include "mitkExampleInteractor.h"
#include "mitkMouseMoveEvent.h"
#include <mitkPointOperation.h>
#include "mitkRenderingManager.h"
#include "mitkInternalEvent.h"
//
#include "mitkDispatcher.h"
#include "mitkBaseRenderer.h"
#include <mitkPropertyList.h>

void mitk::ExampleInteractor::ConnectActionsAndFunctions()
{
  // connect the action names of the state machine pattern with function within
  // this DataInteractor
  CONNECT_FUNCTION("addPoint", AddPoint);
  CONNECT_FUNCTION("enoughPoints", SelectPoint);
}

bool mitk::ExampleInteractor::AddPoint(StateMachineAction*, InteractionEvent* interactionEvent)
{
  // cast InteractionEvent to a position event in order to read out the mouse position
  // we stay here as general as possible so that a different state machine pattern
  // can reuse this code with MouseRelease or MouseMoveEvents.
  InteractionPositionEvent* positionEvent = dynamic_cast<InteractionPositionEvent*>(interactionEvent);
  if (positionEvent != NULL)
  {
    // query the position of the mouse in the world geometry
    mitk::Point3D point = positionEvent->GetPositionInWorld();
    m_PointSet->InsertPoint(m_NumberOfPoints, point, 0);
    m_NumberOfPoints++;
    GetDataNode()->SetData(m_PointSet);
    GetDataNode()->Modified();

    // read how many points we accept from the config properties
    mitk::PropertyList::Pointer properties = GetPropertyList();
    std::string maxNumber;
    properties->GetStringProperty("NumberOfPoints",maxNumber);
    if (m_NumberOfPoints >=  atoi(maxNumber.c_str());)
    {
      // create internal event that signal that the maximal number of points is reached
      InternalEvent::Pointer event = InternalEvent::New(NULL,this, "enoughPointsAdded");
      // add the internal event to the event queue of the Dispatcher
      positionEvent->GetSender()->GetDispatcher()->QueueEvent(event.GetPointer());
    }
    // update the RenderWindow to show new points
    mitk::RenderingManager::GetInstance()->RequestUpdateAll();
    return true;
  }
  else
  {
    return false;
  }
}

mitk::ExampleInteractor::ExampleInteractor() :
{
  m_NumberOfPoints = 0;
  m_PointSet = PointSet::New(); // create PointSet to store our point in
}

mitk::ExampleInteractor::~ExampleInteractor()
{
}

bool mitk::ExampleInteractor::EnoughPoints(StateMachineAction*, InteractionEvent*)
{
  GetDataNode()->SetProperty("contourcolor", ColorProperty::New(1.0, 1.0, 0.0));
  mitk::RenderingManager::GetInstance()->RequestUpdateAll();
  return true;
}

\endcode

 */
