/**

\page DataManagementPage The Data Management Concept

As MITK is used to process large and diverse data the management thereof becomes an important issue. In order to abstract the management of data from the actual format of the data it is encapsulated.

\section DataManagementPageEncapsulation Data Encapsulation

All data objects, like images or surfaces, are contained in DataNodes. These DataNodes describe the data itself (mitk::BaseData), how they can be rendered in 2D or 3D (a list of mitk::Mapper), what mitk::Interactor is associated with it, and a list of arbirary properties (name, visibility, opacity, etc.). Information about the position of a data object in space/time is stored in a Geometry, which is attached to the data object itself, not to the node.

\subsection DataManagementPageBaseData BaseData

This is the base class for all data objects. It itself inherits from itk::DataObject.

\subsection DataManagementPageDataNode DataNode

This class encapsulates a BaseData object and provide uniform handling.

\subsection DataManagementPageDataStorage DataStorage

The MITK DataStorage manages and stores DataNodes. Besides adding and removing nodes it provides advanced functionality such as getting a list of all DataNodes currently in the DataStorage which match a specific type (e.g. image, surface ) or have a specific name or other property.

There can be different DataStorages. 

A usage example for a class deriving from QmitkAbstractView:
\code
  mitk::DataNode::Pointer resultNode = mitk::DataNode::New();
  std::string nameOfResultImage = node->GetName();
  nameOfResultImage.append("Otsu");
  resultNode->SetProperty("name", mitk::StringProperty::New(nameOfResultImage) );
  resultNode->SetProperty("binary", mitk::BoolProperty::New(true) );
  resultNode->SetData( mitk::ImportItkImage ( filter->GetOutput() ) );

  this->GetDataStorage()->Add(resultNode, node);
\endcode

\section DataManagementPageOwnType Adding an own data type

To extent MITKs capabilities by adding anown data type there are several things which should be done. Depending on whether the data type is completely unlike any of the existing ones, or derived from one of them some steps can possibly be ommitted.

<ol>
  <li> Add your data type
  <li> Add reader and writer and register them
  <li> Add mapper
</ol>

*/